function [P] = make_EM1D_P_3D(work_dir,meshfile,Q,nnodes,interp_dist,interp_max,ax,ay)
% Function make_1D_P_3D
% Create interpolator (P) matrix to transfer 1D column models 
% onto 3D mesh using a distance weighted average scheme
%
% INPUT
% work_dir  : directory of files
% meshfile  : Mesh file in UBC format
% Q         : Querry matrix generated by function "make_EM1DFM_Q_3D.m"
% nnodes    : Number of observation points to be used for the averaging
%
% SUB-FUNCTION CALLS
% get_UBC_mesh.m    : Load mesh file and output [5xn] matrix

%% FOR DEV ONLY

% clear all 
% close all
% 
% work_dir    = 'C:\Users\dominiquef\Dropbox\DIGHEM\Processed_data\1DEMInversions\ALL_DF';
% meshfile    = 'UBC_mesh.msh';
% load([work_dir '\Q']);
% 
% nnodes=4;

%% SCRIPT STARTS HERE

%% Load mesh
[meshfile]=get_UBC_mesh([work_dir '\' meshfile]);
nx = meshfile(1,1); %size(X,1);    %number of cell in X
ny = meshfile(1,2); %size(X,2);    %number of cell in Y
nz = meshfile(1,3); %size(X,3);    %number of cell in Z

mcell = nx*ny*nz;

% Cell size array
dx = meshfile(3,1:nx);
dy = meshfile(4,1:ny);

% Corner grid
x0 = meshfile(2,1);
y0 = meshfile(2,2);

% Create 3D cell center array
xc = x0 + cumsum(dx) - dx/2;
yc = y0 + cumsum(dy) - dy/2;


%% Create array of points from Q matrix
nsnds = size(Q,1); % Number of soundings

obsx = zeros(nsnds,1);
obsy = zeros(nsnds,1);

for ii = 1 : nsnds

    obsx(ii) = xc(Q(ii,1));
    obsy(ii) = yc(Q(ii,2));
    
end

%% Create Projector and Querry matrices
% Cycles to all the cells in 2D and find closest observation points from
% which information will be taken after inversion. The weights are
% calculate for a = 1/r such that:
% m = (a1*x1 + a2*x2) / (a1 + a2)
P = spalloc(mcell,mcell,nnodes*mcell);
count = 1;
progress = 0;
tic
    
for jj = 1 : ny

    for ii = 1 : nx

        r = ( ( (xc(ii) - obsx(:)) / ax ).^2 +...
                ( (yc(jj) - obsy(:)) / ay ).^2 ) .^ 0.5;


        % Compute inverse distance + small number to avoid singularity
        r = 1./(r+interp_dist);

        % Sort points by distance and keep n smallest
        [rsort,index] = sort(r,'descend');

        % Compute weighted average
        denom = sum(rsort(1:nnodes));

        % Assign weights to the right nodes
        numer = zeros(nx,ny); 
        
        % Treshold the distance
        if max(rsort) > 1/interp_max;
            for qq = 1 : nnodes

                numer(Q(index(qq),1),Q(index(qq),2)) = rsort(qq)/denom;

            end
            
        end
        
        numer = reshape(numer,1,nx*ny);

        % Create weight matrix for current column of model
        w = kron(numer,speye(nz));

          
        P(count:(count+nz-1),:) = w ;


        count = count + nz;


        % Prompt iteration and time message
        d_iter = floor(ii*jj/(nx*ny)*20);

        if  d_iter > progress

            fprintf('Computed %i pct of data in %8.5f sec\n',d_iter*5,toc)

            progress = d_iter;        
            tic

        end
            
    end

end



