% Inversion code with lp,lq norm for 3D magnetostatic problem
% Read input file and proceede with inversion
% 
% DEVELOPMENT CODE
% Under sub-functions are required to run the code
% Written by: Dominique Fournier 
% Last update: July 1th, 2014

clear all
close all

addpath ..\..\FUNC_LIB\;
% Project folders
work_dir = 'C:\Users\dominiquef.MIRAGEOSCIENCE\ownCloud\Research\Modelling\Synthetic\SingleBlock';
inpfile   = 'MAG3Cinv.inp'; 

dsep = '\';

[meshfile,obsfile,topofile,mstart,mref,magfile,weightfile,chi_target,alphas,beta,bounds,norm_vec,eps_p,eps_q,FLAG1,FLAG2, ROT] = MAG3Cinv_read_inp([work_dir dsep inpfile]);

% mtrue = load([work_dir '\..\Effec_sus.sus']);
% Load mesh file and convert to vectors (UBC format)
[xn,yn,zn] = read_UBC_mesh([work_dir dsep meshfile]);
dx = xn(2:end) - xn(1:end-1); nx = length(dx);
dy = yn(2:end) - yn(1:end-1); ny = length(dy);
dz = zn(1:end-1) - zn(2:end); nz = length(dz);

mcell = (length(xn)-1) * (length(yn)-1) * (length(zn)-1);

% Rotation angles (azm dip)
% ROT = [80 0];


% Ploting variables
minc = 0.001;
intc = 0.005;
maxc = 0.01;

%% Load observation file (3C UBC-MAG format)
[H, BI, BD, MI, MD, obsx, obsy, obsz, d, wd] = read_MAG3D_obs([work_dir dsep obsfile]);
% plot_mag3C(obsx,obsy,d,I,D,'Observed 3C-data')
% plot_TMI(obsx,obsy,d,d,wd,'Observed vs Predicted Magnitude');

ndata = length(d);
Wd   = spdiags(1./wd,0,ndata,ndata);

%% Create model magnetization vectors
% Load magnetization model
if isempty(magfile) == 1
    
    mag_azmdip = [ones(mcell,1)*MD ones(mcell,1)*MI];
    mag_xyz = azmdip_2_xyz( mag_azmdip(:,1) , mag_azmdip(:,2) );
    
else
    
    mag_xyz = load([work_dir dsep magfile]);
    
end

% Load weights model
if isempty(weightfile) == 1
    
    w = ones(4*mcell,1);
    
else
    
    w = load([work_dir dsep weightfile]);
    
end

% Create or load reference model
if ischar(mref)==1
    
    mref = load([work_dir dsep mref]);
    
else
    
    mref = ones(mcell,1)*mref;
    
end

% Create or load reference model
if ischar(mstart)==1
    
    mstart = load([work_dir dsep mstart]);
    
else
    
    mstart = ones(mcell,1)*mstart;
    
end

% w = load([work_dir '\w.dat']);

% Create bound vector
lowBvec = ones(mcell,1) * bounds(1);
uppBvec = ones(mcell,1) * bounds(2);

%% Load topography
if isempty(topofile)==1
    
    nullcell = ones(nx*ny*nz,1);
    
else
    % Load topo
    topo = read_UBC_topo([work_dir dsep topofile]);
    [nullcell,tcell,~] = topocheck(xn,yn,zn,topo+1e-5);
    
end

save([work_dir dsep 'nullcell.dat'],'-ascii','nullcell');
%% Initialize dynamic cells



% Create selector matrix for active cells
X = spdiags(nullcell,0,mcell,mcell);
X = X(nullcell==1,:);

mactv = sum(nullcell);

mstart = X * mstart;
mref = X * mref;
mag_xyz = X * mag_xyz;
lowBvec = X* lowBvec;
uppBvec = X * uppBvec;

%% Generate s and t vectors for the different lp zones
if ischar(norm_vec)==1
    
    lpmat = load([work_dir dsep norm_vec]);
    [s,LP] = find_zones(lpmat);

    % Smooth out the regions with 8-point averager
    % Power determine the transition length
    A = get_AVG_8pt(dx,dy,dz);
    A = A*(A*A);
    A = spdiags(1./sum(A,2),0,mcell,mcell) *A;
    
    trans = A*s;
    t = X * trans;
%     t(t>0) = sqrt(t(t>0));
%     LP = X * LP;
    
    s = trans==1;
    s = X * s;
    
else
    
    LP = norm_vec;
    s= X * ones(mcell,1);
    t= X * ones(mcell,1);

end


%% Create model magnetization vectors
% Azimuth and dip of magnitization

M = [spdiags(H * mag_xyz(:,1),0,mactv,mactv);spdiags(H * mag_xyz(:,2),0,mactv,mactv);spdiags(H * mag_xyz(:,3),0,mactv,mactv)];


%% Load T matrix generated by FMAG3C
% load([work_dir '\G']);
[G,~,~] = MAGSEN_Func(work_dir,dsep,xn,yn,zn, H, BI, BD, MI, MD, obsx, obsy, obsz,nullcell, 'NULL', 'G', 3, min(dx)/4);

G = (G * M);


%% Apply data weighting
G   = Wd * G;
d = Wd * d;



%% Create gradient matrices and corresponding volume vectors
[~, gx, gy, gz, V, Vx, Vy, Vz] = get_GRAD_op3D_SQUARE_Kron(dx,dy,dz,nullcell,'FWR');
[~, gx_b, gy_b, gz_b, ~, ~, ~, ~] = get_GRAD_op3D_SQUARE_Kron(dx,dy,dz,nullcell,'BACK');
% [Ws, V ] = getWs3D(dx,dy,dz,X);

% Cross-diagonal
gxy = kron(kron(spdiags(ones(ny,1)*[-0.5,1],[-1,0],ny,ny),spdiags(ones(nx,1)*[-1,1],[-1,0],nx,nx)),speye(nz));
gxy(gxy<0) = 0;
gxy(gxy==1) = -1;
gxy(gxy==0.5) = 1;

gyx = kron(kron(spdiags(ones(ny,1)*[-0.5,1],[-1,0],ny,ny),spdiags(ones(nx,1)*[-1,1],[0,1],nx,nx)),speye(nz));
gyx(gyx>0) = 0;
gyx(gyx==-0.5) = 1;

%% Compute depth weighting
% wr = get_wr(obsx, obsy, obsz, D, I, xn, yn, zn, nullcell, wr_flag);
% save([work_dir '\wr.dat'],'-ascii','wr');

% wr = load([work_dir '\wr.dat']);
%### TEST USING APPROXIMATE SENSITIVITY
wr = sqrt(sum(G.^2,1));
wr = sqrt(wr'/max(wr));

% j = (j'.^0.5)./v.^2;
% 
%         wr = (j / max(j)).^0.5;
        
% wr = X * wr;
% Wr = spdiags(wr,0,mcell,mcell);

%%
Ws =  V * spdiags(X * ( w(1:mcell) .* wr ) ,0,mactv,mactv);
Wx =  V * spdiags(X * ( w(1+mcell:2*mcell) .* wr ) ,0,mactv,mactv);
Wy =  V * spdiags(X * ( w(1+2*mcell:3*mcell) .* wr ) ,0,mactv,mactv);
Wz =  V * spdiags(X * ( w(1+3*mcell:4*mcell) .* wr ) ,0,mactv,mactv);



%% Rotate gradient operators

for rr = 1 : size(ROT,1)
%     thetaVec = ones(mcell,1) * azm;
%     phiVec = ones(mcell,1) * dip(rr);
%     psiVec = ones(mcell,1) * psi;
% 
%     rot = zeros(3,3,mcell);

    Rz = @(x)   [cosd(x) -sind(x) 0;
                sind(x) cosd(x) 0;
                0 0 1];

    Ry = @(x)   [cosd(x) 0 sind(x);
                0 1 0;
                -sind(x) 0 cosd(x)];

    rz = Rz(2*ROT(rr,1));
%     rz = rz*spdiags(sum(abs(rz),2).^-1,0,3,3);
    
    ry = Ry(ROT(rr,2));
%     ry = ry*spdiags(sum(abs(ry),2).^-1,0,3,3);
    
    Rot = ry*rz;
    % Scale the rows


    % rot(1,3,:) =  sind(thetaVec);
    % rot(2,3,:) =  cosd(thetaVec) .* sind(psiVec);
    % rot(3,3,:) =  cosd(thetaVec) .* cosd(psiVec);
    % 
    % rot(2,2,:) =  cosd(phiVec) .* cosd(psiVec)   + sind(phiVec) .* sind(thetaVec) .* sind(psiVec);
    % rot(1,2,:) = -sind(phiVec) .* cosd(thetaVec);
    % rot(3,2,:) = -cosd(phiVec) .* sind(psiVec)   + sind(phiVec) .* sind(thetaVec) .* sind(psiVec);
    % 
    % rot(1,1,:) =  cosd(phiVec) .* cosd(thetaVec);
    % rot(2,1,:) =  sind(phiVec) .* cosd(psiVec)   - cosd(phiVec) .* sind(thetaVec) .* sind(psiVec);
    % rot(3,1,:) = -sind(phiVec) .* sind(psiVec)   - cosd(phiVec) .* sind(thetaVec) .* cosd(psiVec);
    % 
    % rxx = spdiags(squeeze(rot(1,1,:)),0,mcell,mcell);
    % rxy = spdiags(squeeze(rot(1,2,:)),0,mcell,mcell);
    % rxz = spdiags(squeeze(rot(1,3,:)),0,mcell,mcell);
    % ryx = spdiags(squeeze(rot(2,1,:)),0,mcell,mcell);
    % ryy = spdiags(squeeze(rot(2,2,:)),0,mcell,mcell);
    % ryz = spdiags(squeeze(rot(2,3,:)),0,mcell,mcell);
    % rzx = spdiags(squeeze(rot(3,1,:)),0,mcell,mcell);
    % rzy = spdiags(squeeze(rot(3,2,:)),0,mcell,mcell);
    % rzz = spdiags(squeeze(rot(3,3,:)),0,mcell,mcell);

    rxx = spdiags(ones(mactv,1)*Rot(1,1),0,mactv,mactv);
    rxy = spdiags(ones(mactv,1)*Rot(1,2),0,mactv,mactv);
    rxz = spdiags(ones(mactv,1)*Rot(1,3),0,mactv,mactv);
    ryx = spdiags(ones(mactv,1)*Rot(2,1),0,mactv,mactv);
    ryy = spdiags(ones(mactv,1)*Rot(2,2),0,mactv,mactv);
    ryz = spdiags(ones(mactv,1)*Rot(2,3),0,mactv,mactv);
    rzx = spdiags(ones(mactv,1)*Rot(3,1),0,mactv,mactv);
    rzy = spdiags(ones(mactv,1)*Rot(3,2),0,mactv,mactv);
    rzz = spdiags(ones(mactv,1)*Rot(3,3),0,mactv,mactv);
    
    if ROT(rr,1) <= 45
        
      Gx = abs(rxx) * gx + abs(rxy) * gyx;
      Gy = abs(ryx) * gxy - abs(ryy) * gy_b;
      
    else
        
        Gx = -abs(rxx) * gy_b + abs(rxy) * gyx;
        Gy = abs(ryx) * gxy - abs(ryy) * gx_b;  
      
    end
%     Gx = rxx * (gx + gx_b) + rxy * (gy + gy_b) + rxz * (gz + gz_b);

%       Gx = gxy;
      
%     if Rot(1,2)<0
%         Gx = Gx + rxy * gy_b;
%     else
%         Gx = Gx + rxy * gy;
%     end
% 
%     if Rot(1,3)<0   
%         Gx = Gx + rxz * gz_b;    
%     else   
%         Gx = Gx + rxz * gz;    
%     end

%     Gy = ryx * (gx + gx_b) + ryy * (gy + gy_b) + ryz * (gz + gz_b);

%       Gy = gyx;
%     if Rot(2,1)<0
%         Gy = Gy + ryx * gx_b;
%     else
%         Gy = Gy + ryx * gx;
%     end
% 
%     if Rot(2,3)<0   
%         Gy = Gy + rzy * gz_b;    
%     else   
%         Gy = Gy + rzy * gz;    
%     end

    Gz = rzx * (gx + gx_b) + rzy * (gy + gy_b) + rzz * (gz + gz_b);
%     if Rot(3,1)<0
%         Gz = Gz + rzx * gx_b;
%     else
%         Gz = Gz + rzx * gx;
%     end
% 
%     if Rot(3,2)<0   
%         Gz = Gz + rzy * gy_b;    
%     else   
%         Gz = Gz + rzy * gy;    
%     end



    %% START INVERSION

    target = chi_target * ndata;     % Target misifit

    % Compute total objective function
    objfunc = @(m,phim,b) sum( ( G * m - d ).^2 ) + (m)' * b * phim * (m);

    % Initialize inversion
    invmod      = mstart;       % Initial model       

    phi_init    = sum((G * invmod - d).^2);   % Initial misfit
    phi_d       = phi_init;        


    % Message prompt
    % head = ['lp' num2str(pvec) '_lq' num2str(qvec) '_mu' num2str(ll)];
    logfile = [work_dir '\MAG3C_TMI.log'];
    fid = fopen(logfile,'w');
    fprintf(fid,'Starting lp inversion \n');
    fprintf(fid,'Starting misfit %e\n',phi_init);
    fprintf(fid,'Target misfit %e\n',target);
    fprintf(fid,'Iteration:\t\tBeta\t\tphid\t\tphis\t\t ');
    fprintf(fid,'phix\t\tphiy\t\tphiz\t\tphim\t\tphi\t\t ');
    fprintf(fid,'#cut cells \t # CG Iter\n');


    % Initiate active cell
    Pac = speye(mactv);


    count= 0; % Initiate iteration count 
    tncg = 0; % Compute total number of CG iterations for the whole inversion
    % leml = 0;
    phi = [];
    phi_m = [];

    lp_count = 0;
    dphim = 1;
    switcher = 0; % Switcher defines the different modes of the inversion
    % switcher 0: Run the usual l2-l2 inversion, beta decreases by 2
    % switcher 1: Run the lp-lq inversion, beta decreases by 0.8
    % swircher 2: End on inversion - model update < treshold


    while switcher ~= 3 


        count=count+1;

        if switcher == 0     

            if isempty(eps_p)
                delta_p(count) = 0.1;
            else
                delta_p(count) = eps_p;
            end

            if isempty(eps_q)
                delta_q(count) = 0.1;
            else
                delta_q(count) = eps_q;
            end
    %                     [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF(invmod,V,Ws,Vx,Wx,Vy,Wy,Vz,Wz,alpha,2,2,1);
            [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF_3D(invmod,mref,1,Ws,Wx,Wy,Wz,Gx,Gy,Gz,ones(mactv,1),alphas,[2 2 2 2 1],FLAG1,FLAG2,switcher,delta_p(count),delta_q(count));

            if isempty(beta)==1

                temp = randn(mactv,1);
                beta = sum(G*temp.^2) / (temp'*MOF*temp) * 1e+6 ;
    %             beta = 1e+5;
            end

            phi(count) = norm(G*invmod - d).^2 +...
                        invmod' * beta(count) * MOF * invmod;
    %         tresh = dkdt(2,delta(count));
    %         tresh_s = 1;
    %         tresh_xyz = 1;
        else

            lp_count = lp_count + 1;

            if lp_count == 1
    %             target = target /10;
                % Fix treshold for smallness term
                [epsp,epsq] = get_eps(invmod,10,Gx,Gy,Gz);
                if isempty(eps_p)
                    eps_p = epsp;
                end

                if isempty(eps_q)
                    eps_q = epsq;
                end

                model_out =  X'*invmod;
                model_out(nullcell==0) = -100;
                save([work_dir dsep 'MAG3D_TMI_l2l2.sus'],'-ascii','model_out');
                write_MAG3D_TMI([work_dir dsep 'MAG3D_TMI_l2l2.pre'],H,BI,BD,MI,MD,obsx,obsy,obsz,(G*invmod).*wd,wd);

            end

            if delta_p(end) > eps_p %&& switcher == 1%(dphi_p(end) > 2 || lp_count ==1) && switch_p == 0

    %             delta_p(count) = delta_p(count-1)*.5;
                delta_p(count) = eps_p;
                if delta_p(count) < eps_p

                    delta_p(count) = eps_p;

                end
            else 

                delta_p(count) = delta_p(count-1);%delta_p(count-1);

            end

            if delta_q(end)> eps_q %&& switcher == 1%(dphi_q(end) > 2 || lp_count ==1) && switch_q == 0

    %             delta_q(count) = delta_q(count-1)*.5;
                delta_q(count) = eps_q;
                if delta_q(count) < eps_q

                    delta_q(count) = eps_q;

                end

            else

                switch_q = 1;
                delta_q(count) = delta_q(count-1);%delta_q(count-1);

            end


            if dphim(end)  < 1 && lp_count>1%traffic_s(end)*100 <= 1  && traffic_xyz(end)*100 <= 1

                fprintf('\n# # ADJUST BETA # #\n');
                switcher = 2;

            else

                fprintf('\n# # LP-LQ ITER# #\n');

            end


            [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF_3D(invmod,mref,phi_m(end),Ws,Wx,Wy,Wz,Gx,Gy,Gz,t,alphas,LP,FLAG1,FLAG2,switcher,delta_p(count),delta_q(count));

    %         tresh = dkdt(LP(:,1),delta(count));


        end

        m_in = invmod;
        %dmdx = sqrt( (Wx * invmod).^2 + (Wy * invmod).^2 + (Wz * invmod).^2 );

    %     group_s(count) = sum(abs(m_in) <= eps_p);
    %     group_xyz(count) = sum(abs(dmdx) <= eps_q);

        %% Jacobi Pre-conditionner
        diagA = sum(G.^2,1) + beta(count)*spdiags(MOF,0)';
        PreC     = Pac * spdiags(1./diagA(:),0,mactv,mactv);

        %% Gauss-Newton steps

        fprintf('\n# # # # # # # # #\n');
        fprintf('BETA ITER: \t %i  \nbeta: \t %8.5e \n',count,beta(count));
        fprintf('eps_p: \t %8.5e \t eps_p*: \t %8.5e\n',delta_p(count),eps_p)
        fprintf('eps_q: \t %8.5e \t eps_q*: \t %8.5e\n',delta_q(count),eps_q)
        % Save previous model before GN step


        [invmod, ncg, Pac] = GN_PCG_solver( G, invmod, mref, d, phi(end), beta(count) , PreC, Pac, lowBvec, uppBvec, MOF, aVRWs, aVRWx, aVRWy, aVRWz, FLAG1 );

        tncg = tncg + ncg;

        %% Save iteration and continue


%         % Measure the update length
%         if count==1 
% 
%             rdm(count) =  1;
%             gdm(1) = norm(m_in - invmod);
% 
%         else
% 
%             gdm(2) = norm(m_in - invmod);
%             rdm(count) = abs( gdm(2) - gdm(1) ) / norm(invmod);
% 
%             gdm(1) = gdm(2);
% 
%         end

        phi_d(count) = sum(( G*invmod - d ).^2);
        phi_m(count) = (invmod)'*(MOF)*(invmod);
        phi(count) = objfunc(invmod,MOF,beta(count));

        if count ~= 1

            dphim(count) = abs(phi_m(count) - phi_m(count-1)) / phi_m(count) *100;

        end
        % Get truncated cells
        tcells = spdiags(Pac);



        fprintf(' phi_d:\t %8.5e \n',phi_d(count))
        fprintf(' phi_m:\t %8.5e \n',phi_m(count))
        fprintf(' dphi_m:\t %8.5e \n',dphim(count))


        fprintf('Number of Inactive cells: %i\n',sum(tcells));
        fprintf('Number of CGS iterations: %i\n\n',ncg);

        % Get next beta
        [switcher,beta(count+1)] = cool_beta(beta(count),phi_d(count),dphim(count),target,switcher,0.25,1);


        % Right log file
        fprintf(fid,' \t %i \t %8.5e ',count,beta(count));
        fprintf(fid,' \t %8.5e ',phi_d(count));
        fprintf(fid,' \t %8.5e ',sum( (aVRWs*invmod).^2 ) );
        fprintf(fid,' \t %8.5e ',sum( (aVRWx*invmod).^2 ));
        fprintf(fid,' \t %8.5e ',sum( (aVRWy*invmod).^2 ));
        fprintf(fid,' \t %8.5e ',sum( (aVRWz*invmod).^2 ));
        fprintf(fid,' \t %8.5e ',invmod'*MOF*invmod);
        fprintf(fid,' \t %8.5e ',phi(count));
        fprintf(fid,' \t\t %i ',sum(tcells));
        fprintf(fid,' \t\t %i\n',ncg);


    
        model_out =  X'*invmod;
        model_out(nullcell==0) = -100;
        save([work_dir dsep 'MAG3D_TMI_lplq.sus'],'-ascii','model_out')
%         write_MAG3D_TMI([work_dir dsep 'MAG3D_TMI_lplq.pre'],H,BI,BD,MI,MD,obsx,obsy,obsz,(G*invmod).*wd,wd);


    end
        
            %% Get section model and save to gif
        model_out = reshape(model_out,nz,nx,ny);
        m_2D = squeeze(model_out(12,:,:))'; 

        xx = xn(1) + cumsum(dx) - dx/2;
        yy = yn(1) + cumsum(dy) - dy/2;
        
        figure(5)
        h = imagesc(m_2D);hold on
        set(h,'alphadata',m_2D~=-100)

        contour(m_2D,minc:intc:maxc,'k')
        caxis([0 maxc]);
        cmap =[1 1 1;0.900280117988586 0.963585436344147 0.990476191043854;0.800560235977173 0.927170872688293 0.980952382087708;0.700840353965759 0.89075630903244 0.971428573131561;0.601120471954346 0.854341745376587 0.961904764175415;0.501400589942932 0.817927181720734 0.952380955219269;0.401680678129196 0.78151261806488 0.942857146263123;0.301960796117783 0.745098054409027 0.933333337306976;0.328808456659317 0.754902005195618 0.897435903549194;0.355656117200851 0.764705896377563 0.861538469791412;0.382503777742386 0.774509787559509 0.82564103603363;0.40935143828392 0.7843137383461 0.789743602275848;0.436199098825455 0.79411768913269 0.753846168518066;0.463046759366989 0.803921580314636 0.717948734760284;0.489894419908524 0.813725471496582 0.682051301002502;0.51674211025238 0.823529422283173 0.64615386724472;0.543589770793915 0.833333373069763 0.610256433486938;0.570437431335449 0.843137264251709 0.574358999729156;0.597285091876984 0.852941155433655 0.538461565971375;0.624132752418518 0.862745106220245 0.502564132213593;0.650980412960052 0.872549057006836 0.466666668653488;0.677828073501587 0.882352948188782 0.430769234895706;0.704675734043121 0.892156839370728 0.394871801137924;0.731523394584656 0.901960790157318 0.358974367380142;0.75837105512619 0.911764740943909 0.32307693362236;0.785218715667725 0.921568632125854 0.287179499864578;0.812066376209259 0.9313725233078 0.251282066106796;0.838914036750793 0.941176474094391 0.215384617447853;0.865761697292328 0.950980424880981 0.179487183690071;0.892609357833862 0.960784316062927 0.143589749932289;0.919457018375397 0.970588207244873 0.107692308723927;0.946304678916931 0.980392158031464 0.0717948749661446;0.973152339458466 0.990196108818054 0.0358974374830723;1 1 0;1 0.966666638851166 0;1 0.933333337306976 0;1 0.899999976158142 0;1 0.866666674613953 0;1 0.833333313465118 0;1 0.800000011920929 0;1 0.766666650772095 0;1 0.733333349227905 0;1 0.699999988079071 0;1 0.666666686534882 0;1 0.633333325386047 0;1 0.600000023841858 0;1 0.566666662693024 0;1 0.533333361148834 0;1 0.5 0;1 0.466666668653488 0;1 0.433333337306976 0;1 0.400000005960464 0;1 0.366666674613953 0;1 0.333333343267441 0;1 0.300000011920929 0;1 0.266666680574417 0;1 0.233333334326744 0;1 0.200000002980232 0;1 0.16666667163372 0;1 0.133333340287209 0;1 0.100000001490116 0;1 0.0666666701436043 0;1 0.0333333350718021 0;1 0 0];
        colormap(cmap);
        axis square
        hold on
        grid on
        ylabel('$y$', 'interpreter', 'latex','FontSize',14)
        xlabel('$x$', 'interpreter', 'latex','FontSize',14)
%         set(gca,'YDir','normal')
        hold on
%         set(gca,'XTickLabel',[])
        set(get(gca,'YLabel'),'Rotation',360);
        colorbar
        title(['Rotation: ' num2str(rot_a(rr))])
        
        if length(rot_a) > 1

            frame = getframe(figure(5));
            im = frame2im(frame);
            [imind,cm] = rgb2ind(im,256);
            if rr == 1;
              imwrite(imind,cm,[work_dir '\field.gif'],'gif', 'Loopcount',inf,'DelayTime',1);
            else
              imwrite(imind,cm,[work_dir '\field.gif'],'gif','WriteMode','append','DelayTime',1);
            end

        end
    
        beta = [];
        delta_p = [];
        delta_q = [];
end
%%
%     save([work_dir '\TMI_v2_' 'p' num2str(pvec) 'q' num2str(qvec) 'l' num2str(ll) '_delta_1em' num2str(abs(log10(delta(count)))) '.sus'],'-ascii','model_out')
%     write_MAG3D_TMI([work_dir '\TMI_v2_' 'p' num2str(pvec) 'q' num2str(qvec) 'l' num2str(ll) '_delta_1em' num2str(abs(log10(delta(count)))) '.pre'],H,I,Dazm,obsx,obsy,obsz,(G*invmod).*wd,wd);
% plot_TMI(obsx,obsy,d.*wd,(G*invmod).*wd,wd,'Obs vs Pred')
% %%           
% % leml = norm(invmod - mtrue,1);
% fprintf(fid,'End of lp inversion. Number of iterations: %i\n',count);
% fprintf(fid,'Final Number of CG iterations: %i\n',tncg);
% fprintf('Final Number of CG iterations: %i\n',tncg);
% %             fprintf('Final data misfit: %8.3e. Final l1-model error: %8.3e\n\n',phi_d(count),norm(m-model_out,1))
% fclose(fid);
% 
%  
% %%
% figure;
% [h,line1,line2] = plotyy(1:count,phi_d,1:count,phi_m);
% hold on
% xlim(h(1),[1 count-1])
% xlim(h(2),[1 count-1])
% ylim(h(1),[0 max(phi_d)])
% ylim(h(2),[min(phi_m)*0.95 max(phi_m)*1.1])
% 
% set(line1,'LineWidth',2);
% set(line2,'LineWidth',2,'LineStyle','--');
% 
% plot(h(1),[1 count],[ndata ndata],'k--')
% 
% % Find closest misfit to target
% [~,idx] =(min(abs(phi_d - ndata)));
% plot(h(1),idx,phi_d(idx),'kx')
% text(idx,phi_d(idx),'$\phi_d^*=N$','interpreter', 'latex','FontSize',14,'VerticalAlignment','bottom','HorizontalAlignment','left','Parent',h(1))
% 
% plot(h(1),2,phi_d(2),'k.','MarkerSize',12)
% text(2,phi_d(2),'$\phi_d^{(k)}$','interpreter', 'latex','FontSize',14,'VerticalAlignment','bottom','HorizontalAlignment','left','Parent',h(1))
% 
% % plot(h(2),count-1,phi_m(end-1),'k.','MarkerSize',12)
% text(count-2,phi_m(end-2),'$\phi_m^{(k)}$','interpreter', 'latex','FontSize',14,'VerticalAlignment','bottom','HorizontalAlignment','right','Parent',h(2))
% 
% ylabel(h(1),'$\phi_d$','interpreter', 'latex','FontSize',14,'Rotation',360)
% ylabel(h(2),'$\phi_m$','interpreter', 'latex','FontSize',14,'Rotation',360)
% xlabel('$\beta\;Iteration$','interpreter', 'latex','FontSize',14)
% 
% %% Plot model distribution
% mm = sort(abs(invmod));
% gradmm = mm./(mm.^2 + delta_p(end).^2).^(1-LP(1,1)/2);
% figure;
% [n, xout] =hist(abs(invmod),500); hold off
% [h_plot,h1,h2] = plotyy(xout,n,mm,gradmm/max(gradmm),'bar','plot');  
% hold(h_plot(1),'on');
% hold(h_plot(2),'on');
% set(h2,'LineWidth',2,'Color','c')
% axis(h_plot(1),[0 0.01 00 500])
% ylabel(h_plot(2),'$\hat{g}(m)$','interpreter', 'latex')
% ylabel(h_plot(1),'Hist(m)')
% xlabel('m')
% 
% set(h1,'barwidth', 1, 'basevalue', 1,'FaceColor',[0.7 0.7 0.7],'LineWidth',0.5);
% 
% plot(h_plot(2),[delta_p(end) delta_p(end)],[0 max(n)],'r--','LineWidth',2)