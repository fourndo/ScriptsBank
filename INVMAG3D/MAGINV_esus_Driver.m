% Generate model and observations for 3D gravity
% Dominique Fournier 2013/01/23
% close all
clear all
close all

% addpath C:\Users\dominiquef\Dropbox\Master\INVMAG3D\

addpath ..\FUNC_LIB\;

% Project folders
work_dir = 'C:\Users\dominiquef.MIRAGEOSCIENCE\ownCloud\Research\Modelling\Synthetic\Nut_Cracker\Effective_Susc';
inpfile   = 'MAG3Cinv.inp'; 

[meshfile,obsfile,mstart,mref,magfile,weightfile,chi_target,alphas,beta,bounds,norm_vec,FLAG1,FLAG2] = MAG3Cinv_read_inp([work_dir '\' inpfile]);

% Load mesh file and convert to vectors (UBC format)
[xn,yn,zn] = read_UBC_mesh([work_dir '\' meshfile]);
dx = xn(2:end) - xn(1:end-1); nx = length(dx);
dy = yn(2:end) - yn(1:end-1); ny = length(dy);
dz = zn(1:end-1) - zn(2:end); nz = length(dz);

mcell = (length(xn)-1) * (length(yn)-1) * (length(zn)-1);

pct_cutoff = 50;


%% Load observation file (3C UBC-MAG format)
[H, I, Dazm, D, obsx, obsy, obsz, d, wd] = read_MAG3D_obs([work_dir '\' obsfile]);
% plot_mag3C(obsx,obsy,d,I,D,'Observed 3C-data')
% plot_TMI(obsx,obsy,d,d,wd,'Observed vs Predicted Magnitude');

ndata = length(obsx);

% if mod(ndata,1)~=0
%     
%     fprintf('Data does not appear to be 3C. Please revise...\n');
%     break
%     
% end

% datax = d(1:ndata) ; wdx = wd(1:ndata);
% datay = d( (ndata+1) : (2*ndata)) ; wdy = wd( (ndata+1) : (2*ndata) );
% dataz = d( (2*ndata+1) : (3*ndata)) ; wdz = wd( (2*ndata+1) : (3*ndata) );

% Check if the data is 3C or directly amplitude
if size(d,1) > ndata
    
    datax = d(1:ndata) ; wdx = abs(datax)*0.05 + 0.05*std(datax);
    datay = d( (ndata+1) : (2*ndata)) ; wdy = abs(datay)*0.05 + 0.05*std(datay);
    dataz = d( (2*ndata+1) : (3*ndata)) ; wdz = abs(dataz)*0.05 + 0.05*std(dataz);

    ampd = sqrt( datax.^2 + datay.^2 + dataz.^2 );
    wd = sqrt( wdx.^2 + wdy.^2 + wdz.^2 );

    Wd   = spdiags(1./wd,0,ndata,ndata);

else
    
    ampd = d;
    Wd   = spdiags(1./wd,0,ndata,ndata);
    
end


%% Create model magnetization vectors
% Load magnetization model
if isempty(magfile) == 1
    
    mag_azmdip = [ones(mcell,1)*(Dazm) ones(mcell,1)*(I)];
    mag_xyz = azmdip_2_xyz( mag_azmdip(:,1) , mag_azmdip(:,2) );
    
else
    
    mag_xyz = load([work_dir '\' magfile]);
    
    % Normalize vector to make sure unity
    mag_xyz = mag_xyz./kron([1 1 1],sqrt(sum(mag_xyz.^2,2)));
    
end

% Load weights model
if isempty(weightfile) == 1
    
    w = ones(4*mcell,1);
    
else
    
    w = load([work_dir '\' weightfile]);
    
end


% Create or load reference model
if ischar(mref)==1
    
    mref = load([work_dir '\' mref]);
    
else
    
    mref = ones(mcell,1)*mref;
    
end

% Create or load reference model
if ischar(mstart)==1
    
    mstart = load([work_dir '\' mstart]);
    
else
    
    mstart = ones(mcell,1)*mstart;
    
end

% Create bound vector
lowBvec = ones(mcell,1) * bounds(1);
uppBvec = ones(mcell,1) * bounds(2);

%% Initialize dynamic cells
load([work_dir '\nullcell.dat']);

% Create selector matrix for active cells
X = spdiags(nullcell,0,mcell,mcell);
X = X(nullcell==1,:);

mstart = X * mstart;
mref = X * mref;
mag_xyz = X * mag_xyz;

mactv = sum(nullcell);

mstart = X * mstart;
mref = X * mref;
mag_xyz = X * mag_xyz;
lowBvec = X* lowBvec;
uppBvec = X * uppBvec;

%% Create model magnetization vectors
% Azimuth and dip of magnitization

M = [spdiags(H * mag_xyz(:,1),0,mactv,mactv);spdiags(H * mag_xyz(:,2),0,mactv,mactv);spdiags(H * mag_xyz(:,3),0,mactv,mactv)];

%% Generate s and t vectors for the different lp zones
if ischar(norm_vec)==1
    
    lpmat = load([work_dir '\' norm_vec]);
    [s,LP] = find_zones(lpmat);

    % Smooth out the regions with 8-point averager
    % Power determine the transition length
    A = get_AVG_8pt(dx,dy,dz);
    A = A*(A*A);
    A = spdiags(1./sum(A,2),0,mcell,mcell) *A;
    
    trans = A*s;
    t = X * trans;
%     t(t>0) = sqrt(t(t>0));
%     LP = X * LP;
    
    s = trans==1;
    s = X * s;
    
else
    
    LP = norm_vec;
    s= X * ones(mcell,1);
    t= X * ones(mcell,1);

end



%% Load T matrix generated by FMAG3C

%% Compute depth weighting
% wr = get_wr(obsx, obsy, obsz, D, I, xn, yn, zn, nullcell, wr_flag);
% save([work_dir '\wr.dat'],'-ascii','wr');
load([work_dir '\wr.dat']);
% wr = wr.^(4/5);
wr = X * wr;
Wr = spdiags(wr,0,mactv,mactv);
IWr = spdiags(1./wr,0,mactv,mactv);

%% Create gradient matrices and corresponding volume vectors
[~, Gx, Gy, Gz, V, Vx, Vy, Vz] = get_GRAD_op3D_SQUARE(dx,dy,dz,nullcell,X);
% [Ws, V ] = getWs3D(dx,dy,dz,X);

Ws =  V * spdiags(X * ( w(1:mcell)  ) ,0,mactv,mactv);
Wx =  Vx * spdiags(X * ( w(1+mcell:2*mcell)  ) ,0,mactv,mactv);
Wy =  Vy * spdiags(X * ( w(1+2*mcell:3*mcell)  ) ,0,mactv,mactv);
Wz =  Vz * spdiags(X * ( w(1+3*mcell:4*mcell)  ) ,0,mactv,mactv);



%% Forward operator and apply depth weighting
load([work_dir '\Tx']);
Fx = Tx * M * IWr;
clear Tx

load([work_dir '\Ty']);
Fy = Ty * M * IWr;
clear Ty

load([work_dir '\Tz']);
Fz = Tz * M * IWr;
clear Tz


%% Apply data weighting
Fx = Wd * Fx ;
Fy = Wd * Fy ;
Fz = Wd * Fz ;

d = Wd * ampd;

ampB = @(m) ( (Fx * m).^2 + (Fy * m).^2 + (Fz * m).^2 ) .^ 0.5;

%% ATTEMP AT PENALIZING CELL VOLUME
wv = 1./diag(V,0);
wv = wv/max(wv);

Wv = spdiags(wv,0,mactv,mactv);
%% Inversion
target = chi_target * ndata;
 
% fprintf('Iteration %i of %i.\n',sub2ind([nl,nq,np],ll,qq,pp),np*nq*nl); 
count=1;

comp_phi = @(m,phi,l) sum( ( ampB(m) - d ).^2 ) +...
    (m)' * l * phi * (m);
 
            
% Initialize inversion
invmod      = Wr * mstart;       % Initial model        

phi_init    = sum((ampB(invmod) - d).^2);   % Initial misfit
phi_d       = phi_init;


% Message prompt
%             head = ['lp' num2str(pvec(pp)) '_lq' num2str(qvec(qq)) '_mu' num2str(lvec(ll))];
logfile = [work_dir '\MAGINV_esus_.log'];
fid = fopen(logfile,'w');
fprintf(fid,'Starting Effective Susceptibility inversion\n');
fprintf(fid,'Starting misfit %e\n',phi_init);
fprintf(fid,'Target misfit %e\n',target);
fprintf(fid,'Iteration:\t\tBeta\t\tphid\t\tphis\t\t ');
fprintf(fid,'phix\t\tphiy\t\tphiz\t\tphim\t\tphi\t\t ');
fprintf(fid,'#cut cells \t # CG Iter\n');


% Initiate active cell
Pac = speye(mactv);

count= 0; % Initiate iteration count 
tncg = 0; % Compute total number of CG iterations for the whole inversion
% leml = 0;
phi = [];
phi_m = [];
lp_count = 0;
switcher = 0; % Switcher defines the different modes of the inversion
% switcher 0: Run the usual l2-l2 inversion, beta decreases by 2
% switcher 1: Run the lp-lq inversion, beta decreases by 0.8
% swircher 2: End on inversion - model update < treshold

traffic_s = 1;    % Measures the number of points/iteration passing the lp corner
traffic_xyz = 1;    % Measures the number of points/iteration passing the lp corner
group_s = 1;  % Measures the number of lower than the lp corner

while switcher ~= 3

    count=count+1;
      


    if  switcher == 0                

        delta_s(count) = (prctile(abs(invmod(invmod > 0)),pct_cutoff))*3;
        delta_xyz(count) = (prctile(abs(invmod(invmod > 0)),pct_cutoff))*3;

%                     [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF(invmod,V,Ws,Vx,Wx,Vy,Wy,Vz,Wz,alpha,2,2,1);
        [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF_3D_v2(invmod,mref,1,Ws,Wx,Wy,Wz,Gx,Gy,Gz,t,alphas,[2 2 2 2 1],FLAG1,FLAG2,switcher,delta_s(count),delta_xyz(count));

        if isempty(beta)==1

            magB   = ampB(invmod)  ;
    
            bx  = spdiags( Fx * invmod , 0 , ndata, ndata);
            by  = spdiags( Fy * invmod , 0 , ndata, ndata);
            bz  = spdiags( Fz * invmod , 0 , ndata, ndata);

        %     lBl   = ampB(invmod);

            lBl   = spdiags( magB.^-1 , 0 , ndata, ndata);

            J   = (lBl * [bx by bz]) *  ([Fx;Fy;Fz] ) ;
    
            temp = randn(mactv,1);
            beta = sum((J*temp).^2) / (temp'*MOF*temp) * 1e+2 ;
            
        end
        
        phi(count) = comp_phi(invmod,MOF,beta(count));
        
        tresh_s = 1;
        tresh_xyz = 1;
        
    else

        lp_count = lp_count+1;

        if lp_count == 1
%             target = target /10;
            % Fix treshold for smallness term
            tresh_s = prctile(abs(invmod(invmod > 0)),pct_cutoff);%0.001;
            delta_s(count) = tresh_s*2;%x_tresh.^2;
            
            
            
            % Fix treshold for smoothness term
            dmdx = sqrt( (Wx * invmod).^2 + (Wy * invmod).^2 + (Wz * invmod).^2 );
            tresh_xyz = prctile(abs(dmdx(dmdx > 0)),pct_cutoff);%0.001;%
            delta_xyz(count) = tresh_xyz*2;%x_tresh.^2;
            
            
        end

        if traffic_s(end)*100 > 1 && switcher == 1
            
            
            
            figure(1)
            if lp_count==1
            
                subplot(1,2,1) 
                %%%% TEMPORARY CHANGE
%                 target = target / 4;
            else
                subplot(1,2,2)   
                delta_s(count) = delta_s(count-1)/2;
            end
            xx = sort(abs(invmod));
            mm = xx./(xx.^2 + delta_s(end).^2).^(1-LP(1)/2);
            [n, xout] =hist(abs(invmod),100); hold off
            [h_plot,h1,h2] = plotyy(xout,n,xx,mm/max(mm),'bar','plot');  
            hold(h_plot(1),'on');
            hold(h_plot(2),'on');
            set(h2,'LineWidth',2)
                
            ylim(h_plot(1),[0 mactv]);
            xlim(h_plot(1),[0 max(abs(invmod))])
            xlim(h_plot(2),[0 max(abs(invmod))])

            axis(h_plot(1),'square')
            axis(h_plot(2),'square')
    %                 [n, xout] =hist(h_plot(1),abs(invmod),100);
            set(h1,'barwidth', 1, 'basevalue', 1,'FaceColor',[0.7 0.7 0.7],'LineWidth',0.5);

            plot(h_plot(2),[tresh_s tresh_s],[0 max(n)],'r--','LineWidth',2)

            set(h_plot(1),'yscale','log')

            hold off

            
        else

            delta_s(count) = delta_s(count-1);

        end
        
        if traffic_xyz(end)*100 > 1 && switcher == 1
            
            
            
            dmdx = sqrt( (Wx * invmod).^2 + (Wy * invmod).^2 + (Wz * invmod).^2 );
            
            figure(2)
            if lp_count==1
            
                subplot(1,2,1) 
            else
                subplot(1,2,2) 
                delta_xyz(count) = delta_xyz(count-1)/2;  
            end
            xx = sort(abs(dmdx));
            mm = xx./(xx.^2 + delta_xyz(end).^2).^(1-LP(2)/2);
            [n, xout] =hist(abs(dmdx),100); hold off
            [h_plot,h1,h2] = plotyy(xout,n,xx,mm/max(mm),'bar','plot');  
            hold(h_plot(1),'on');
            hold(h_plot(2),'on');
            set(h2,'LineWidth',2)
                
            ylim(h_plot(1),[0 1e+4]);
            xlim(h_plot(1),[0 max(dmdx)])
            xlim(h_plot(2),[0 max(dmdx)])
    
            axis(h_plot(1),'square')
            axis(h_plot(2),'square')
    %                 [n, xout] =hist(h_plot(1),abs(invmod),100);
            set(h1,'barwidth', 1, 'basevalue', 1,'FaceColor',[0.7 0.7 0.7],'LineWidth',0.5);

            plot(h_plot(2),[tresh_xyz tresh_xyz],[0 max(n)],'r--','LineWidth',2)

            set(h_plot(1),'yscale','log')

            hold off

            
        else

            delta_xyz(count) = delta_xyz(count-1);

        end
        
        if traffic_xyz(end)*100 <= 1 || traffic_s(end)*100 <= 1
            
            switcher = 2;
            
        end
          
        fprintf('\n# # LP-LQ ITER# #\n');
        [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF_3D_v2(invmod,mref,phi_m(end),Ws,Wx,Wy,Wz,Gx,Gy,Gz,t,alphas,LP,FLAG1,FLAG2,switcher,delta_s(count),delta_xyz(count));

%         tresh = dkdt(LP(:,1),delta(count));

        
    end


    %% Gauss Newton Steps
    
    fprintf('\n# # # # # # # # #\n');
    fprintf('BETA ITER: \t %i  \nbeta: \t %8.5e \n',count,beta(count));
    
    % Save current model
    m_in = invmod;
    tncg = 0;
    ggdm = 1;       % Mesure the relative change in rel|dm|
    ddm = [1 1];    % Mesure of change in model update |dm|
    solves = 1;
      

%         magB   = ampB(invmod)  ;
%         bx  = spdiags( Fx * invmod , 0 , ndata, ndata);
%         by  = spdiags( Fy * invmod , 0 , ndata, ndata);
%         bz  = spdiags( Fz * invmod , 0 , ndata, ndata);
% 
%         magB   = ampB(invmod)  ;
% 
%         lBl   = spdiags( magB.^-1 , 0 , ndata, ndata);
% 
%         J   = lBl * ([bx by bz] *  ([Fx;Fy;Fz] * spdiags(invmod,0,mactv,mactv)) );    


                  
    
    phi_in = phi(end);
    while solves < 6 && ggdm > 1e-3

        magB   = ampB(invmod)  ;

        bx  = spdiags( Fx * invmod , 0 , ndata, ndata);
        by  = spdiags( Fy * invmod , 0 , ndata, ndata);
        bz  = spdiags( Fz * invmod , 0 , ndata, ndata);

        %     lBl   = ampB(invmod);

        lBl   = spdiags( magB.^-1 , 0 , ndata, ndata);

        J   = (lBl * [bx by bz]) *  ([Fx;Fy;Fz]) ;

        A = [ J  ;...
        sqrt( beta(count) ) * aVRWs ;...
        sqrt( beta(count) ) * aVRWx ;...
        sqrt( beta(count) ) * aVRWy ;...
        sqrt( beta(count) ) * aVRWz ];

        diagA   = sum(J.^2,1) + beta(count)*spdiags(MOF,0)';
        PreC    = Pac * spdiags(1./diagA(:),0,mactv,mactv);
        switch FLAG1

            case 'SMOOTH_MOD'
                g = [- (magB - d) ; ...
            - sqrt( beta(count) ) * ( aVRWs * (invmod-mref) ) ;...
            - sqrt( beta(count) ) * ( aVRWx * (invmod) ) ;...
            - sqrt( beta(count) ) * ( aVRWy * (invmod) ) ;...
            - sqrt( beta(count) ) * ( aVRWz * (invmod) ) ];

            case 'SMOOTH_MOD_DIF'
                g = [- (magB - d) ; ...
            - sqrt( beta(count) ) * ( aVRWs * (invmod-mref) ) ;...
            - sqrt( beta(count) ) * ( aVRWx * (invmod-mref) ) ;...
            - sqrt( beta(count) ) * ( aVRWy * (invmod-mref) ) ;...
            - sqrt( beta(count) ) * ( aVRWz * (invmod-mref) ) ];
        end 
        

        %% Projected steepest descent
        dm = zeros(mactv,1);
        [dm,r,ncg] = PCGLSQ( dm, A , g, PreC, Pac);
        fprintf('CG iter %i \n',ncg);
        
        %% Step length, line search                
        tncg = tncg+ncg; % Record the number of CG iterations

        temp = spdiags(Pac);
        
        % Combine active and inactive cells step if active bounds
        if sum(temp)~=mactv
            
            rhs_a = ( speye(mactv) - Pac ) * (A'*g);
            dm_i = max( abs( dm ) );
            dm_a = max( abs(rhs_a) );                
            dm = dm + rhs_a * dm_i / dm_a /10 ;

        end
        gamma = 2;
        
         % Reduce step length in order to reduce phid
        phi_out = phi_in;
        m_temp = invmod;
        while (phi_out >= phi_in || gamma == 2) && gamma > 1e-4

%             phi_temp(2) = phi_temp(1);

            gamma = 0.5 * gamma;

            gdm = gamma * dm;

            ddm(2) = norm(gdm);

            m_temp = invmod + gdm;

            lowb = m_temp <= lowBvec;
            uppb = m_temp >= uppBvec;

            % Apply bound on model
            m_temp(lowb==1) = lowBvec(lowb==1);
            m_temp(uppb==1) = uppBvec(uppb==1);

            % Update projection matrix
            Pac = spdiags((lowb==0).*(uppb==0),0,mactv,mactv);
            phi_out = comp_phi(m_temp,MOF,beta(count));


        end

        phi_in = phi_out;

        if solves == 1

            ggdm = 1;
            ddm(1) = ddm(2);

        else

            ggdm = ddm(2)/ddm(1);

        end


        % Update model
        invmod = m_temp;

        fprintf('GN iter %i |g| rel:\t\t %8.5e\n',solves,ggdm);

        solves = solves + 1;
         
    phi_d(count) = sum((ampB(invmod)-d).^2);
    phi_m(count) = (invmod)'*(MOF)*(invmod);
    phi(count) = phi_d(count) + beta(count)*phi_m(count);
         
    end
    
    dmdx = sqrt( (Wx * invmod).^2 + (Wy * invmod).^2 + (Wz * invmod).^2 );
    
    group_s(count) = sum(abs(m_in) <= tresh_s);
    group_xyz(count) = sum(abs(dmdx) <= tresh_xyz);
    
    clear A J 
    %% Save results and update beta
    % Measure traffic around the lp corner
    if lp_count >= 1  
        temp = sum(abs(invmod) <= tresh_s);
        traffic_s(count) = abs(group_s(count) - temp) / group_s(count);
        
        dmdx = sqrt( (Wx * invmod).^2 + (Wy * invmod).^2 + (Wz * invmod).^2 );
        temp = sum(abs(dmdx) <= tresh_xyz);
        traffic_xyz(count) = abs(group_xyz(count) - temp) / group_xyz(count);
        

    end
    
    % Measure the update length
    if count==1 
        
        rdm(count) =  1;
        gdm(1) = norm(m_in - invmod);
        
    else
        
        gdm(2) = norm(m_in - invmod);
        rdm(count) = abs( gdm(2) - gdm(1) ) / norm(invmod);
    
        gdm(1) = gdm(2);
        
    end
    

    
    % Get truncated cells
    tcells = spdiags(Pac);
    
    fprintf('---------->')
    fprintf(' misfit:\t %8.5e ',phi_d(count))
    fprintf('Final Relative dm:\t %8.5e ', rdm(count));
    fprintf('<----------\n')
    
    fprintf('Number of Inactive cells: %i\n',sum(tcells));
    fprintf('Number of CGS iterations: %i\n\n',ncg);
    
    [switcher,beta(count+1)] = cool_beta(beta(count),phi_d(count),rdm(count),target,switcher,0.1,1e-2);

    fprintf(fid,' \t %i \t %8.5e ',count,beta(count));
    fprintf(fid,' \t %8.5e ',phi_d(count));
    fprintf(fid,' \t %8.5e ', alphas(1)*sum(aVRWs*invmod).^2) ;
    fprintf(fid,' \t %8.5e ', alphas(2)*sum(aVRWx*invmod).^2) ;
    fprintf(fid,' \t %8.5e ', alphas(3)*sum(aVRWy*invmod).^2) ;
    fprintf(fid,' \t %8.5e ', alphas(4)*sum(aVRWz*invmod).^2) ;
    fprintf(fid,' \t %8.5e ',invmod'*MOF*invmod);
    fprintf(fid,' \t %8.5e ',phi(count));
    fprintf(fid,' \t\t %i ',sum(tcells));
    fprintf(fid,' \t\t %i\n',ncg);
   % Output interation result

    model_out = X'*IWr*invmod;
    model_out(nullcell==0) = -100;
    save([work_dir '\MAGINV_esus_iter_' num2str(count) '.sus'],'-ascii','model_out')
    write_MAG3D_TMI([work_dir '\MAG3D_esus_iter_' num2str(count) '.pre'],H,I,Dazm,obsx,obsy,obsz,ampB(invmod).*wd,wd);




end

count=count-1;            

fprintf(fid,'End of lp inversion. Total Number of iterations: %i\n',tncg);
fclose(fid);
           

