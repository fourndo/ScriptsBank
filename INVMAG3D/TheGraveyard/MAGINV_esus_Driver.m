% Generate model and observations for 3D gravity
% Dominique Fournier 2013/01/23
% close all
clear all
close all

% addpath C:\Users\dominiquef\Dropbox\Master\INVMAG3D\

addpath ..\FUNC_LIB\;

% Project folders
work_dir = 'C:\Users\dominiquef.MIRAGEOSCIENCE\Google Drive\Research\Modelling\Synthetic\Nut_Cracker\Effective_Susc';
inpfile   = 'MAG3Cinv.inp'; 

[meshfile,obsfile,mstart,mref,magfile,chi_target,alphas,beta,bounds,pvec,qvec,lvec,FLAG] = MAG3Cinv_read_inp([work_dir '\' inpfile]);

% Load mesh file and convert to vectors (UBC format)
[xn,yn,zn] = read_UBC_mesh([work_dir '\' meshfile]);
dx = xn(2:end) - xn(1:end-1); nx = length(dx);
dy = yn(2:end) - yn(1:end-1); ny = length(dy);
dz = zn(1:end-1) - zn(2:end); nz = length(dz);

mcell = (length(xn)-1) * (length(yn)-1) * (length(zn)-1);

% Initialize dynamic cells
load([work_dir '\nullcell.dat']);
Di = spdiags(nullcell,0,mcell,mcell);

% Load observation file (3C UBC-MAG format)
[H, I, Dazm, D, obsx, obsy, obsz, d, wd] = read_MAG3D_obs([work_dir '\' obsfile]);
% plot_mag3C(obsx,obsy,d,I,D,'Observed 3C-data')
% plot_TMI(obsx,obsy,d,d,wd,'Observed vs Predicted Magnitude');

ndata = length(obsx);

if mod(ndata,1)~=0
    
    fprintf('Data does not appear to be 3C. Please revise...\n');
    break
    
end

% datax = d(1:ndata) ; wdx = wd(1:ndata);
% datay = d( (ndata+1) : (2*ndata)) ; wdy = wd( (ndata+1) : (2*ndata) );
% dataz = d( (2*ndata+1) : (3*ndata)) ; wdz = wd( (2*ndata+1) : (3*ndata) );

% Check if the data is 3C or directly amplitude
if size(d,1) > ndata
    
    datax = d(1:ndata) ; wdx = abs(datax)*0.05 + 0.05*std(datax);
    datay = d( (ndata+1) : (2*ndata)) ; wdy = abs(datay)*0.05 + 0.05*std(datay);
    dataz = d( (2*ndata+1) : (3*ndata)) ; wdz = abs(dataz)*0.05 + 0.05*std(dataz);

    ampd = sqrt( datax.^2 + datay.^2 + dataz.^2 );
    wd = sqrt( wdx.^2 + wdy.^2 + wdz.^2 );

    Wd   = spdiags(1./wd,0,ndata,ndata);

else
    
    ampd = d;
    Wd   = spdiags(1./wd,0,ndata,ndata);
    
end


%% Create model magnetization vectors
% Load magnetization model
if isempty(magfile) == 1
    
    mag_azmdip = [ones(mcell,1)*Dazm ones(mcell,1)*I];
    mag_xyz = azmdip_2_xyz( mag_azmdip(:,1) , mag_azmdip(:,2) );
    
else
    
    mag_xyz = load([work_dir '\' magfile]);
    
end

% Create or load reference model
if ischar(mref)==1
    
    mref = load([work_dir '\' mref]);
    
else
    
    mref = ones(mcell,1)*mref;
    
end

% Create or load reference model
if ischar(mstart)==1
    
    mstart = load([work_dir '\' mstart]);
    
else
    
    mstart = ones(mcell,1)*mstart;
    
end
%% Create model magnetization vectors
% Azimuth and dip of magnitization

M = [spdiags(H * mag_xyz(:,1),0,mcell,mcell);spdiags(H * mag_xyz(:,2),0,mcell,mcell);spdiags(H * mag_xyz(:,3),0,mcell,mcell)];

%% Load T matrix generated by FMAG3C

%% Compute depth weighting
% wr = get_wr(obsx, obsy, obsz, D, I, xn, yn, zn, nullcell, wr_flag);
% save([work_dir '\wr.dat'],'-ascii','wr');
load([work_dir '\wr.dat']);
% wr = (wr).^(3/2);
%% Create gradient matrices and corresponding volume vectors
[Wx, Wy, Wz, Vx, Vy, Vz] = get_GRAD_op3D_v4(dx,dy,dz,nullcell);
[Ws, V ] = getWs3D(dx,dy,dz);

%% Depth weighting
IWr = spdiags(1./wr,0,mcell,mcell);
Wr = spdiags(wr,0,mcell,mcell);


%% Forward operator and apply depth weighting
load([work_dir '\Tx']);
Fx = Tx * M;
clear Tx

load([work_dir '\Ty']);
Fy = Ty * M;
clear Ty

load([work_dir '\Tz']);
Fz = Tz * M;
clear Tz

Fx = Wd * Fx * IWr;
Fy = Wd * Fy * IWr;
Fz = Wd * Fz * IWr;

ampB = @(m) ( (Fx * m).^2 + (Fy * m).^2 + (Fz * m).^2 ) .^ 0.5;

%% Inversion
delta=1e-10;     %Small term in compact function

nl=length(lvec);
nq=length(qvec);
np=length(pvec);

target = chi_target * ndata;

d = Wd * ampd;
 
% fprintf('Iteration %i of %i.\n',sub2ind([nl,nq,np],ll,qq,pp),np*nq*nl); 
count=1;

comp_phi = @(m,phi,l) sum( ( ampB(m) - d ).^2 ) +...
    (m)' * l * phi * (m);

for ll= 1:length(lvec)

    for pp = 1:length(pvec)
        
        for qq = 1:length(qvec)   
            
            % Initialize inversion
            invmod      = Wr * mstart;       % Initial model        
            
            phi_init    = sum((ampB(invmod) - d).^2);   % Initial misfit
            phi_d       = phi_init;
            phi_m       = [];         
            
            count=1;
            
            % Message prompt
            head = ['lp' num2str(pvec(pp)) '_lq' num2str(qvec(qq)) '_mu' num2str(lvec(ll))];
            logfile = [work_dir '\Log_lBl_' head '.log'];
            fid = fopen(logfile,'w');
            fprintf(fid,'Starting lp inversion %s\n',head);
            fprintf(fid,'Starting misfit %e\n',phi_init);
            fprintf(fid,'Target misfit %e\n',target);
            fprintf(fid,'Iteration:\t\tBeta\t\tphid\t\tphis\t\t ');
            fprintf(fid,'phix\t\tphiy\t\tphiz\t\tphim\t\tphi\t\t ');
            fprintf(fid,'#cut cells \t # CG Iter\n');
            
            % Initiate active cell
            lowb = zeros(mcell,1); % Logical for lower boundded cells
            uppb = zeros(mcell,1); % Logical for upper boundded cells
            Pac = spdiags(nullcell.*(lowb==0).*(uppb==0),0,mcell,mcell);
            
            WxtWx = ( Vx * Wx )' * ( Vx * Wx ) ;
            WytWy = ( Vy * Wy )' * ( Vy * Wy ) ;
            WztWz = ( Vz * Wz )' * ( Vz * Wz ) ;

            WstWs = ( V * Ws )' * ( V * Ws ) ;
                    
            while phi_d(end)>target

                bx  = spdiags( Fx * invmod , 0 , ndata, ndata);
                by  = spdiags( Fy * invmod , 0 , ndata, ndata);
                bz  = spdiags( Fz * invmod , 0 , ndata, ndata);

                lBl   = ampB(invmod);
        
                lBl   = spdiags( lBl.^-1 , 0 , ndata, ndata);

                J   = (lBl * [bx by bz]) * ( [Fx;Fy;Fz] );
                
                if count==1                 

%                     [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF(invmod,V,Ws,Vx,Wx,Vy,Wy,Vz,Wz,alpha,2,2,1);
                    [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF_mGRAD_v3(invmod,mref,nx,ny,nz,V,Ws,Vx,Wx,Vy,Wy,Vz,Wz,alphas,2,2,1,FLAG);
              
                    MOF_start = MOF;
                    
                    if isempty(beta)==1
                        
                        beta = full( sum(sum(J.^2,1)) / sum(diag(MOF,0)) * 1e+4 );
                        
                    end
                        
                    lambda = beta ;
                    phi =  comp_phi(invmod,MOF,lambda);
                    
                else
%                     [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF(invmod,V,Ws,Vx,Wx,Vy,Wy,Vz,Wz,alpha,pvec(pp),qvec(qq),lvec(ll));

                    [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF_mGRAD_v3(invmod,mref,nx,ny,nz,V,Ws,Vx,Wx,Vy,Wy,Vz,Wz,alphas,pvec(pp),qvec(qq),lvec(ll),FLAG);

                    mu = ( invmod'* MOF_start * invmod ) / (invmod'*MOF*invmod ) ;

                    lambda = beta(count) * mu;

                end
                
                
                %% PCG steps
                ncg = 0;
                for npcg = 1:5
                    
                bx  = spdiags( Fx * invmod , 0 , ndata, ndata);
                by  = spdiags( Fy * invmod , 0 , ndata, ndata);
                bz  = spdiags( Fz * invmod , 0 , ndata, ndata);

                lBl   = ampB(invmod)  ;
        
                lBl   = spdiags( lBl.^-1 , 0 , ndata, ndata);

                J   = (lBl * [bx by bz]) * ( [Fx;Fy;Fz] );    
                
                diagA = sum(J.^2,1) + lambda*spdiags(MOF,0)';
                PreC     = Pac * spdiags(1./diagA(:),0,mcell,mcell); 
                
                A = [ J ;...
                    sqrt( lambda ) * aVRWs ;...
                    sqrt( lambda ) * aVRWx ;...
                    sqrt( lambda ) * aVRWy ;...
                    sqrt( lambda ) * aVRWz ];

                switch FLAG
                    
                    case 'SMOOTH_MOD'
                        g = [- (ampB(invmod) - d) ; ...
                    - sqrt( lambda ) * ( aVRWs * (invmod-mref) ) ;...
                    - sqrt( lambda ) * ( aVRWx * (invmod) ) ;...
                    - sqrt( lambda ) * ( aVRWy * (invmod) ) ;...
                    - sqrt( lambda ) * ( aVRWz * (invmod) ) ];
                        
                    case 'SMOOTH_MOD_DIF'
                        g = [- (ampB(invmod) - d) ; ...
                    - sqrt( lambda ) * ( aVRWs * (invmod-mref) ) ;...
                    - sqrt( lambda ) * ( aVRWx * (invmod-mref) ) ;...
                    - sqrt( lambda ) * ( aVRWy * (invmod-mref) ) ;...
                    - sqrt( lambda ) * ( aVRWz * (invmod-mref) ) ];
                end
                
                %% Projected steepest descent
                dm = zeros(mcell,1);
                [dm,r,iter] = PCGLSQ( dm, A , g, PreC, Pac);
                
                %% Step length, line search                
                ncg = ncg+iter; % Record the number of CG iterations

                % Combine active and inactive cells step if active bounds
                if sum(lowb(nullcell==1)==1)~=0
                    rhs_a = ( Di - Pac ) * (A'*g);

                    dm_i = max( abs( dm ) );
                    dm_a = max( abs(rhs_a) );                
                    dm = dm + rhs_a * dm_i / dm_a /10 ;
                    
                end
                gamma = 2;

                % Initialise phi^k
                phi_temp = 0;   
                while phi_temp > phi(end) || gamma == 2
                    
                    gamma = 0.5 * gamma;
                    
                    m_temp = invmod + gamma * dm;
                    lowb(nullcell==1) = m_temp(nullcell==1) <= bounds(1);
                    
                    % Apply bound on model
                    m_temp(lowb==1) = bounds(1);
                    
                    % Update projection matrix
                    Pac = spdiags(nullcell.*(lowb==0),0,mcell,mcell);
                    
                    phi_temp = comp_phi(m_temp,MOF,lambda);
   
                end
                   
                % Update model
                invmod = m_temp;
                end

                phi(count) = comp_phi(invmod,MOF,lambda);
                phi_d(count) = sum((ampB(invmod)-d).^2);

                % Cool beta
                if phi_d(count) < target*2 && count~=1
                    
                  beta(count+1) = 0.5 * beta(count);

                else

                  beta(count+1) = 0.5 * beta(count);

                end


                fprintf(fid,' \t %i \t %8.5e ',count,beta(count));
                fprintf('Iteration: \t %i  \nBeta: \t %8.5e \n',count,beta(count));
                fprintf(fid,' \t %8.5e ',phi_d(count));
                fprintf('phid:\t %8.5e\n',phi_d(count))
                fprintf(fid,' \t %8.5e ',invmod'*alphas(1)*WstWs*invmod);
                fprintf(fid,' \t %8.5e ',invmod'*alphas(2)*WxtWx*invmod);
                fprintf(fid,' \t %8.5e ',invmod'*alphas(3)*WytWy*invmod);
                fprintf(fid,' \t %8.5e ',invmod'*alphas(4)*WztWz*invmod);
                fprintf(fid,' \t %8.5e ',invmod'*MOF*invmod);
                fprintf(fid,' \t %8.5e ',phi(count));
                fprintf(fid,' \t\t %i ',sum(lowb));
                fprintf('Number of Inactive cells: %i\n',sum(lowb));
                fprintf(fid,' \t\t %i\n',ncg);
                fprintf('Number of CGS iterations: %i\n',ncg);
               % Output interation result
               
                model_out = IWr * invmod;
                model_out(nullcell==0) = -100;
                save([work_dir '\lBl_' 'p' num2str(pvec(pp)) 'q' num2str(qvec(qq)) 'l' num2str(lvec(ll)) '_iter_' num2str(count) '.sus'],'-ascii','model_out')
                
                
              count=count+1;
              
            end
            
            count=count-1;            
            
            fprintf(fid,'End of lp inversion. Number of iterations: %i\n',count);
            fclose(fid);
           
        end
        
    end
    
end

