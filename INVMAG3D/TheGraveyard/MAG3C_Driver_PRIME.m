% Inversion code with lp,lq norm for 3D magnetostatic
% DEVELOPMENT CODE
% Under sub-functions are required to run the code
% Written by: Dominique Fournier 
% Last update: 2014/04/10

clear all
close all

addpath ..\FUNC_LIB\;
addpath ..\FUNC_LIB\sliceomatic\;
% Project folders
work_dir = 'C:\Users\dominiquef.MIRAGEOSCIENCE\Documents\Projects\Research\Modelling\Synthetic\Dual_block';
obsfile     = 'Synthetic_IND_TMI_5m.obs';
meshfile    = 'Mesh_40m.msh';
model_sus   = 'Dual_susc.sus';

% Load mesh file and convert to vectors (UBC format)
[xn,yn,zn]=read_UBC_mesh([work_dir '\' meshfile]);
dx = xn(2:end) - xn(1:end-1);
dy = yn(2:end) - yn(1:end-1);
dz = zn(1:end-1) - zn(2:end);

mcell = (length(xn)-1) * (length(yn)-1) * (length(zn)-1);

% Load synthetic model
m = load([work_dir '\' model_sus]);
load([work_dir '\nullcell.dat']);

% Load observation file (3C UBC-MAG format)
[H, I, Dazm, D, obsx, obsy, obsz, d, wd] = read_MAG3D_obs([work_dir '\' obsfile]);
% plot_mag3C(obsx,obsy,d,I,D,'Observed 3C-data')
% plot_TMI(obsx,obsy,d,d,wd,'Observed vs Predicted Magnitude');

ndata = length(d);
Wd   = spdiags(1./wd,0,ndata,ndata);

nstn = length(obsx);

%% Create model magnetization vectors
m_azm = ones(mcell,1)*Dazm;
m_dip = ones(mcell,1)*I;
mv = azmdip_2_xyz(m_azm,m_dip,mcell);

M = [spdiags(H * mv(:,1),0,mcell,mcell);spdiags(H * mv(:,2),0,mcell,mcell);spdiags(H * mv(:,3),0,mcell,mcell)];


% Create diagonal matrix of remenant mag
% m_azm_REM = load([work_dir '\' model_azm]); m_azm_REM = m_azm_REM(nullcell==1);
% m_dip_REM = load([work_dir '\' model_dip]); m_dip_REM = m_dip_REM(nullcell==1);
% mv_REM = azmdip_2_xyz(m_azm_REM,m_dip_REM,mcell);

% Create diagonal matrix of remenant mag
% M_REM = [spdiags(H * mv_REM(:,1),0,mcell,mcell);spdiags(H * mv_REM(:,2),0,mcell,mcell);spdiags(H * mv_REM(:,3),0,mcell,mcell)];

% M = (M_REM + M_IND)/2;

%% Load T matrix generated by FMAG3C
load([work_dir '\Tx']);
load([work_dir '\Ty']);
load([work_dir '\Tz']);

G = [Tx;Ty;Tz] * M;

clear Tx Ty Tz

% Compute depth weighting
wr = get_wr(obsx, obsy, obsz, xn, yn, zn, nullcell, 'depth');
save([work_dir '\wr.dat'],'-ascii','wr');

%% TMI forward projector
ProG = [spdiags(ones(nstn,1)* (cosd(I) * cosd(D)),0,nstn,nstn) ...
    spdiags(ones(nstn,1)* (cosd(I) * sind(D)),0,nstn,nstn) ...
    spdiags(ones(nstn,1)* sind(I),0,nstn,nstn)];

G = ProG*G;

%% Invertion Steps Start HERE

%% Create gradient matrices and corresponding volume vectors
% [Wx, Vx ] = getWx_3D(dx,dy,dz,nullcell);
% [Wy, Vy ] = getWy_3D(dx,dy,dz,nullcell);
% [Wz, Vz ] = getWz_3D(dx,dy,dz,nullcell);
[Wx, Wy, Wz, Vx, Vy, Vz] = get_GRAD_op3D_v2(dx,dy,dz);
[Ws, v ] = getWs3D(dx,dy,dz);

%% Depth weighting
IWr = spdiags(1./wr,0,mcell,mcell);
Wr = spdiags(wr,0,mcell,mcell);

V = spdiags((v),0,mcell,mcell);

%% Compute sensitivity
% sens = mean((abs(G*V)),1)'/ndata;
% save([work_dir '\sens.dat'],'-ascii','sens');
G = G * IWr;
G   = Wd * G;

target = ndata;%sum((Wd*(data - d)).^2);

d = Wd * d;


%% Inversion
Lx = 120;
Ly = 120;
Lz = 120;


as = 1/Lx^2;
ax = 1;
ay = 1;
az = 1;

% Pick the p-norm, q-norm and scale
pvec = 2%[0 1 2]%0:0.5:2;
qvec = 2%[0 1 2]%0:0.5:2;
lvec = 1.0%[0.5 1 1.5]%0.25:0.5:1.75;

nl=length(lvec);
nq=length(qvec);
np=length(pvec);

% finalmodels = zeros(length(pvec),length(qvec),length(lvec),nx*ny*nz);
% phid = zeros(length(pvec),length(qvec),length(lvec));
% RMS = zeros(length(pvec),length(qvec),length(lvec));
% l2 = zeros(length(pvec),length(qvec),length(lvec));
% l1 = zeros(length(pvec),length(qvec),length(lvec));
% models_out = zeros(length(pvec),length(qvec),length(lvec),mcell);
    
delta=1e-10;     %Small term in compact function

% Compute total objective function
comp_phi = @(m,phi,l) norm(G*(m) - d).^2 +...
    (m)' * l * phi * (m);

counter = 1;               
for ll= 1:length(lvec)

    for pp = 1:length(pvec)
        
        for qq = 1:length(qvec)
                                
            invmod      = Wr* ones(mcell,1)*1e-4;       % Initial model       
            mref        = zeros(mcell,1);       % Reference model 
            
            phi_init    = sum((G*Wr *invmod - d).^2);   % Initial misfit
            phi_d       = phi_init;
            phi_m       = [];         
            
            count=1;
            countbar = 0;
            
            % Message prompt
            head = ['lp: ' num2str(pvec(pp)) ' lq: ' num2str(qvec(qq)) ' psi: ' num2str(lvec(ll))];
            fprintf('Starting lp inversion %s\n',head)
            fprintf('Starting misfit %e\n',phi_init)
            fprintf('Target misfit %e\n',target)
            
            % Initiate active cell
            ProG = spdiags(nullcell,0,mcell,mcell);
            
            while phi_d(end) > target 
                
                
                %First iteration uses the usual smallness and smoothness
                %regularization. Choose a beta on the ratio of the traces 
                % of the elements of objective function
                if count==1                 

                    WxtWx = ( Vx * Wx )' * ( Vx * Wx ) ;
                    WytWy = ( Vy * Wy )' * ( Vy * Wy ) ;
                    WztWz = ( Vz * Wz )' * ( Vz * Wz ) ;

                    WstWs = ( V * Ws )' * ( V * Ws ) ;

                    Rs = speye(mcell);
                    Rx = speye(size(Wx,1));
                    Ry = speye(size(Wy,1));
                    Rz = speye(size(Wz,1));
                    
                    % Scale for gradient norm
                    scale_s     = as * lvec(ll) ;
                    scale_x     = ax * abs( 2.0-lvec(ll) ); 
                    scale_y     = ay * abs( 2.0-lvec(ll) );
                    scale_z     = az * abs( 2.0-lvec(ll) );
                    
                    phim_start = ( ax * WxtWx + ay * WytWy + az * WztWz + as * WstWs ) ;
                    phim = phim_start;          


            
                    beta = sum(sum(G.^2,1)) / sum(diag(phim,0)) * 1e+4 ;
                    lambda = beta ;
                    
                    phi = norm(G*invmod - d).^2 +...
                        invmod' * lambda * phim * invmod;
                    
                else   
                    
                    
                    rs = 1./ ( abs(Ws * invmod) .^( 2-pvec(pp) ) + delta );
%                     rs = rs / max(rs) + 1e-6;

                    Rs = spdiags( rs.^ 0.5 ,0,mcell,mcell);

                    rx = 1./ ( abs(Wx * invmod) .^( 2.0-qvec(qq) ) + delta ) ;
%                     rx = rx / max(rx) + 1e-6;

                    Rx = spdiags( rx .^0.5,0,size(Wx,1),size(Wx,1));
                    
                    ry = 1./ ( abs(Wy * invmod) .^( 2.0-qvec(qq) ) + delta ) ;
%                     ry = ry / max(ry) + 1e-6;

                    Ry = spdiags( ry .^0.5,0,size(Wy,1),size(Wy,1));
                    
                    rz = 1./ ( abs(Wz * invmod) .^( 2.0-qvec(qq) ) + delta ) ;
%                     rz = rz / max(rz) + 1e-6;

                    Rz = spdiags( rz .^0.5,0,size(Wz,1),size(Wz,1));                    
 
                    % Form the matrices by including the weights and volume
                    WxtRxWx = ( Vx * Rx * Wx )' * ( Vx * Rx * Wx ) ;
                    WytRyWy = ( Vy * Ry * Wy )' * ( Vy * Ry * Wy ) ;
                    WztRzWz = ( Vz * Rz * Wz )' * ( Vz * Rz * Wz ) ;
                    WstRsWs = ( V * Rs * Ws )' * ( V * Rs * Ws ) ;

                    phis = (invmod' * WstRsWs * invmod );
                    
                    % Scale the smallest q-norm on the smallest norm
                    scale_s = (invmod' * WstWs * invmod ) / (phis);
                    
                    % Scale the gradient p-norm on the smallest q-norm
                    scale_g = scale_s * as * phis / ( invmod' * (ax *WxtRxWx + ay *WytRyWy + az *WztRzWz) * invmod );
                    
                    % Final scales
                    scale_s = lvec(ll) * scale_s * as;
                    scale_x = (2.0 - lvec(ll)) * scale_g * ax;
                    scale_y = (2.0 - lvec(ll)) * scale_g * ay;
                    scale_z = (2.0 - lvec(ll)) * scale_g * az;

                    % Form the final model objective function
                    phim =  ( scale_s * WstRsWs +...
                    scale_x * WxtRxWx + scale_y * WytRyWy +...
                    scale_z * WztRzWz ) ;

                    % Scale the final model objective function
                    scale(count) = ( invmod'* phim_start * invmod ) / (invmod'*phim*invmod ) ;

                    lambda = beta(count) * scale(count);



                end

                % Direct solver using \
%                 A = G'*G + lambda * phim;
% 
%                 RHS = G'*d;
%                 
%                 invmod = A\RHS;

                %% Pre-conditionner
                diagA = sum(G.^2,1) + lambda*spdiags(phim,0)';
                PreCon     = ProG * spdiags(1./diagA(:),0,mcell,mcell);

                % Gaussian Newton solver
                % Form Hessian and gradient (only half since solving using
                % CGLSQ)
                A = [ G * ProG ;...
                    sqrt( lambda * scale_s ) * V * Rs * Ws * ProG ;...
                    sqrt( lambda * scale_x ) * Vx * Rx * Wx * ProG ;...
                    sqrt( lambda * scale_y ) * Vy * Ry * Wy * ProG ;...
                    sqrt( lambda * scale_z ) * Vz * Rz * Wz * ProG ];

                g = [- (G *invmod - d) ; ...
                    - sqrt( lambda * scale_s ) * ( V * Rs * Ws *  (invmod - mref)) ;...
                    - sqrt( lambda * scale_x ) * ( Vx * Rx * Wx * (invmod - mref) ) ;...
                    - sqrt( lambda * scale_y ) * ( Vy * Ry * Wy * (invmod - mref) ) ;...
                    - sqrt( lambda * scale_z ) * ( Vz * Rz * Wz * (invmod - mref) ) ];
               
                dm = zeros(mcell,1);
                [dm,r,iter] = CGLSQ( dm, A , g, PreCon);
                
                
                % Projected steepest descent
%                 H = P * (G'*G + lambda*phim) *P;
%                     
% 
%                 g = - P*(G'*(G *invmod - d) + lambda*phim*(invmod-mref));
%                 
%                 dm = zeros(mcell,1);
%                 [dm,r,iter]=CGiter(dm,H,g);

                pin = max( abs( dm ) );
                pac = max( abs( (speye(mcell) - ProG) * (A'*g) ) );
                
                p = 1;
                if pin < pac
                    
                    p = pin / pac / 10;
                    
                end
                
                dm = dm + p * ( speye(mcell) - ProG) * (A'*g) ;
                
                %% Step length, line search
                alpha = 2;

                % Initialise phi^k
                phi_temp = 0;   
                while phi_temp > phi(end) || alpha == 2
                    
                    alpha = 0.5 * alpha;
                    
                    m_temp = invmod + alpha * dm;
                    lb =  m_temp > 0;
                    % Apply bound on model
                    m_temp(lb==0) = 0;
                    ProG = spdiags(nullcell.*lb,0,mcell,mcell);
                    
                    phi_temp = comp_phi(m_temp,phim,lambda);
   
                end
                   
                % Update model
                invmod = m_temp;

                
                %% Save iteration and continue
                clear A

                phi(count) = comp_phi(invmod,phim,lambda);
            
                phi_d(count) = sum((G*(invmod)-d).^2);
                phi_m(count) = (invmod)'*(phim)*(invmod);

                % Cool beta
                if phi_d(count) < target*2 && count~=1
                    
                  beta(count+1) = 0.5 * beta(count);

                else

                  beta(count+1) = 0.5 * beta(count);

                end

                fprintf('Iteration: \t %i  \nBeta: \t %8.5e \n',count,beta(count))
                fprintf('phid:\t %8.5e\n',phi_d(count));
                fprintf('phis:\t %8.5e\n',invmod'*as*WstWs*invmod);
                fprintf('phix:\t %8.5e\n',invmod'*ax*WxtWx*invmod);
                fprintf('phiy:\t %8.5e\n',invmod'*ay*WytWy*invmod);
                fprintf('phiz:\t %8.5e\n',invmod'*az*WztWz*invmod);
                fprintf('phim:\t %8.5e\n',invmod'*phim*invmod);
                fprintf('phi:\t %8.5e\n',phi(count));
                fprintf('Number of Inactive cells: %i\n',mcell-sum(lb));
                fprintf('Number of CGS iterations: %i\n',iter);

               % Output interation result
               
                model_out = IWr * invmod;
                model_out(nullcell==0) = -100;
                save([work_dir '\TMI_' 'p' num2str(pvec(pp)) 'q' num2str(qvec(qq)) 'l' num2str(lvec(ll)) '_iter_' num2str(count) '.sus'],'-ascii','model_out')
            
              count=count+1;
              countbar = 0;  
            end
            
            count=count-1;
            % Store result
%             RMS(pp,qq,ll)=(sum((m-model_out).^2)/length(d))^(0.5);
%             l2(pp,qq,ll) = norm(m-model_out,2);
%             l1(pp,qq,ll) = norm(m-model_out,1);
%             phid(pp,qq,ll) = phi_d(count);
%             
%             finalmodels(pp,qq,ll,:) = ones(nx*ny*nz,1)*-100;
%             finalmodels(pp,qq,ll,nullcell==1) = model_out;
            
            
            fprintf('End of lp inversion. Number of iterations: %i\n',count)
            fprintf('Final data misfit: %8.3e. Final l1-model error: %8.3e\n\n',phi_d(count),norm(m-model_out,1))
            
            counter = counter+1;
            
        end
    end
end

 


