% Inversion code with lp,lq norm for 3D magnetostatic problem
% Read input file and proceede with inversion
% 
% DEVELOPMENT CODE
% Under sub-functions are required to run the code
% Written by: Dominique Fournier 
% Last update: July 1th, 2014

clear all
close all

addpath ..\FUNC_LIB\;
% Project folders
work_dir = 'C:\Users\dominiquef.MIRAGEOSCIENCE\Google Drive\Research\Modelling\Synthetic\Nut_Cracker\Induced_MAG3C';
inpfile   = 'MAG3Cinv.inp'; 

[meshfile,obsfile,mstart,mref,magfile,chi_target,alphas,beta,bounds,lp,lq,ll,FLAG] = MAG3Cinv_read_inp([work_dir '\' inpfile]);

% Load mesh file and convert to vectors (UBC format)
[xn,yn,zn] = read_UBC_mesh([work_dir '\' meshfile]);
dx = xn(2:end) - xn(1:end-1); nx = length(dx);
dy = yn(2:end) - yn(1:end-1); ny = length(dy);
dz = zn(1:end-1) - zn(2:end); nz = length(dz);

mcell = (length(xn)-1) * (length(yn)-1) * (length(zn)-1);

% Initialize dynamic cells
load([work_dir '\nullcell.dat']);
Di = spdiags(nullcell,0,mcell,mcell);
            
% Load observation file (3C UBC-MAG format)
[H, I, Dazm, D, obsx, obsy, obsz, d, wd] = read_MAG3D_obs([work_dir '\' obsfile]);
% plot_mag3C(obsx,obsy,d,I,D,'Observed 3C-data')
% plot_TMI(obsx,obsy,d,d,wd,'Observed vs Predicted Magnitude');

ndata = length(d);
Wd   = spdiags(1./wd,0,ndata,ndata);

nstn = length(obsx);

%% Create model magnetization vectors
% Load magnetization model
if isempty(magfile) == 1
    
    mag_azmdip = [ones(mcell,1)*Dazm ones(mcell,1)*I];
    mag_xyz = azmdip_2_xyz( mag_azmdip(:,1) , mag_azmdip(:,2) );
    
else
    
    mag_xyz = load([work_dir '\' magfile]);
    
end

% Create or load reference model
if ischar(mref)==1
    
    mref = load([work_dir '\' mref]);
    
else
    
    mref = ones(mcell,1)*mref;
    
end

% Create or load reference model
if ischar(mstart)==1
    
    mstart = load([work_dir '\' mstart]);
    
else
    
    mstart = ones(mcell,1)*mstart;
    
end

%% Create model magnetization vectors
% Azimuth and dip of magnitization

M = [spdiags(H * mag_xyz(:,1),0,mcell,mcell);spdiags(H * mag_xyz(:,2),0,mcell,mcell);spdiags(H * mag_xyz(:,3),0,mcell,mcell)];


%% TMI forward projector
Ptmi = [spdiags(ones(nstn,1)* (cosd(I) * cosd(D)),0,nstn,nstn) ...
    spdiags(ones(nstn,1)* (cosd(I) * sind(D)),0,nstn,nstn) ...
    spdiags(ones(nstn,1)* sind(I),0,nstn,nstn)];

%% Compute depth weighting
% wr = get_wr(obsx, obsy, obsz, D, I, xn, yn, zn, nullcell, wr_flag);
% save([work_dir '\wr.dat'],'-ascii','wr');
load([work_dir '\wr.dat']);

%% Load T matrix generated by FMAG3C
load([work_dir '\Tx']);
load([work_dir '\Ty']);
load([work_dir '\Tz']);

G = [Tx;Ty;Tz] * M;

clear Tx Ty Tz

G = Ptmi*G;


%% Create gradient matrices and corresponding volume vectors
[Wx, Wy, Wz, Vx, Vy, Vz] = get_GRAD_op3D_v4(dx,dy,dz,nullcell);
[Ws, V ] = getWs3D(dx,dy,dz);

%% Depth weighting
IWr = spdiags(1./wr,0,mcell,mcell);
Wr = spdiags(wr,0,mcell,mcell);

% V = spdiags((v),0,mcell,mcell);

%% Apply depth and data weighting on sensitivity
% sens = mean((abs(G*V)),1)'/ndata;
% save([work_dir '\sens.dat'],'-ascii','sens');
G = G * IWr;
G   = Wd * G;
d = Wd * d;

%% Inversion    
delta=1e-10;     %HARDWIRED: Small term in compact function

target = chi_target * ndata;     % Target misifit

% Compute total objective function
comp_phi = @(m,phim,b) sum( ( G * m - d ).^2 ) + (m)' * b * phim * (m);

counter = 1;               

                
% Initialize inversion
invmod      = Wr * mstart;       % Initial model       

phi_init    = sum((G * invmod - d).^2);   % Initial misfit
phi_d       = phi_init;
phi_m       = [];         

count=1;
countbar = 0;

% Message prompt
head = ['lp' num2str(lp) '_lq' num2str(lq) '_mu' num2str(ll)];
logfile = [work_dir '\Log_' head '.log'];
fid = fopen(logfile,'w');
fprintf(fid,'Starting lp inversion %s\n',head);
fprintf(fid,'Starting misfit %e\n',phi_init);
fprintf(fid,'Target misfit %e\n',target);
fprintf(fid,'Iteration:\t\tBeta\t\tphid\t\tphis\t\t ');
fprintf(fid,'phix\t\tphiy\t\tphiz\t\tphim\t\tphi\t\t ');
fprintf(fid,'#cut cells \t # CG Iter\n');


% Initiate active cell
lowb = zeros(mcell,1); % Logical for lower boundded cells
uppb = zeros(mcell,1); % Logical for upper boundded cells
Pac = spdiags(nullcell.*(lowb==0).*(uppb==0),0,mcell,mcell);

WxtWx = ( Vx * Wx )' * ( Vx * Wx ) ;
WytWy = ( Vy * Wy )' * ( Vy * Wy ) ;
WztWz = ( Vz * Wz )' * ( Vz * Wz ) ;

WstWs = ( V * Ws )' * ( V * Ws ) ;

while phi_d(end) > target 


    %First iteration uses the usual smallness and smoothness
    %regularization. Choose a beta on the ratio of the traces 
    % of the elements of objective function
    if count==1                 

%                     [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF(invmod,V,Ws,Vx,Wx,Vy,Wy,Vz,Wz,alpha,2,2,1);
        [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF_mGRAD_v3(invmod,mref,nx,ny,nz,V,Ws,Vx,Wx,Vy,Wy,Vz,Wz,alphas,2,2,1,FLAG);

        MOF_start = MOF;

        if isempty(beta)==1
            beta = full( sum(sum(G.^2,1)) / sum(diag(MOF,0)) * 1e+4 );

        end

%                     beta = beta ;
        phi = norm(G*invmod - d).^2 +...
            invmod' * beta * MOF * invmod;

    else
%                     [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF(invmod,V,Ws,Vx,Wx,Vy,Wy,Vz,Wz,alpha,pvec(pp),qvec(qq),lvec(ll));

        [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF_mGRAD_v3(invmod,mref,nx,ny,nz,V,Ws,Vx,Wx,Vy,Wy,Vz,Wz,alphas,lp,lq,ll,FLAG);

%                     mu = ( invmod'* MOF_start * invmod ) / (invmod'*MOF*invmod ) ;

%                     beta = beta(count) ;%* mu;

    end


    %% Pre-conditionner
    diagA = sum(G.^2,1) + beta(count)*spdiags(MOF,0)';
    PreC     = Pac * spdiags(1./diagA(:),0,mcell,mcell);

    %% PCG steps
    fprintf('\n# # # # # #\n');
    fprintf('BETA ITER: \t %i  \nbeta: \t %8.5e \n',count,beta(count));

    ncg = 0;
    npcg = 1;
    rddm = 1;
    ddm = [1 1];
    
while npcg < 5 && rddm > 1e-2
    % Gaussian Newton solver
    % Form Hessian and gradient (only half since solving using
    % CGLSQ)
    A = [ G ;...
        sqrt( beta(count) ) * aVRWs ;...
        sqrt( beta(count) ) * aVRWx ;...
        sqrt( beta(count) ) * aVRWy ;...
        sqrt( beta(count) ) * aVRWz ];

     switch FLAG

        case 'SMOOTH_MOD'

        g = [- (G *invmod - d) ; ...
            - sqrt( beta(count) ) * ( aVRWs * (invmod - mref) ) ;...
            - sqrt( beta(count) ) * ( aVRWx * (invmod) ) ;...
            - sqrt( beta(count) ) * ( aVRWy * (invmod) ) ;...
            - sqrt( beta(count) ) * ( aVRWz * (invmod) ) ];

        case 'SMOOTH_MOD_DIF'
                g = [- (G *invmod - d) ; ...
            - sqrt( beta(count) ) * ( aVRWs * (invmod-mref) ) ;...
            - sqrt( beta(count) ) * ( aVRWx * (invmod-mref) ) ;...
            - sqrt( beta(count) ) * ( aVRWy * (invmod-mref) ) ;...
            - sqrt( beta(count) ) * ( aVRWz * (invmod-mref) ) ];
     end

    dm = zeros(mcell,1);
    [dm,r,iter] = PCGLSQ( dm, A , g, PreC, Pac);

    %% Step length, line search                
    ncg = ncg+iter; % Record the number of CG iterations

    % Combine active and inactive cells step if active bounds
    if sum(lowb(nullcell==1)==1)~=0

        rhs_a = ( Di - Pac ) * (A'*g);
        dm_i = max( abs( dm ) );
        dm_a = max( abs(rhs_a) );                
        dm = dm + rhs_a * dm_i / dm_a /10 ;

    end
    gamma = 2;

    % Initialise phi^k
    phi_temp = 0;   
    while phi_temp > phi(end) || gamma == 2

        gamma = 0.5 * gamma;

        gdm = gamma * dm;

        ddm(2) = norm(gdm);

        m_temp = invmod + gdm;
        lowb(nullcell==1) = m_temp(nullcell==1) <= bounds(1);

        % Apply bound on model
        m_temp(lowb==1) = bounds(1);

        % Update projection matrix
        Pac = spdiags(nullcell.*(lowb==0),0,mcell,mcell);

        phi_temp = comp_phi(m_temp,MOF,beta(count));

    end

    if npcg == 1
        
        rddm = 1;
        ddm(1) = ddm(2);
        
    else
        
        rddm = ddm(2)/ddm(1);
    
    end
    
    
    
    % Update model
    invmod = m_temp;
    
    fprintf('GN iter %i |g| rel:\t\t %8.5e\n',npcg,rddm);
    npcg = npcg + 1;
    
end

    %% Save iteration and continue
    clear A

    phi(count) = comp_phi(invmod,MOF,beta(count));

    phi_d(count) = sum(( G*invmod - d ).^2);

    % Cool beta
    if phi_d(count) < target*2 && count~=1

      beta(count+1) = 0.5 * beta(count);

    else

      beta(count+1) = 0.5 * beta(count);

    end
    
    % Print to screen
    fprintf('---------->')
    fprintf(' misfit:\t %8.5e ',phi_d(count))
    fprintf('<----------\n')


    fprintf(fid,' \t %i \t %8.5e ',count,beta(count));
    fprintf(fid,' \t %8.5e ',phi_d(count));
    
    fprintf(fid,' \t %8.5e ',invmod'*alphas(1)*WstWs*invmod);
    fprintf(fid,' \t %8.5e ',invmod'*alphas(2)*WxtWx*invmod);
    fprintf(fid,' \t %8.5e ',invmod'*alphas(3)*WytWy*invmod);
    fprintf(fid,' \t %8.5e ',invmod'*alphas(4)*WztWz*invmod);
    fprintf(fid,' \t %8.5e ',invmod'*MOF*invmod);
    fprintf(fid,' \t %8.5e ',phi(count));
    fprintf(fid,' \t\t %i ',sum(lowb));
    fprintf('Number of Inactive cells: %i\n',sum(lowb));
    fprintf(fid,' \t\t %i\n',ncg);
    fprintf('Number of CGS iterations: %i\n\n',ncg);

    model_out = IWr * invmod;
    model_out(nullcell==0) = -100;
    save([work_dir '\TMI_' 'p' num2str(lp) 'q' num2str(lq) 'l' num2str(ll) '_iter_' num2str(count) '.sus'],'-ascii','model_out')
    write_MAG3D_TMI([work_dir '\TMI_' 'p' num2str(lp) 'q' num2str(lq) 'l' num2str(ll) '_iter_' num2str(count) '.pre'],H,I,Dazm,obsx,obsy,obsz,(G*invmod).*wd,wd)

  count=count+1;
  countbar = 0;  
end

count=count-1;            

fprintf(fid,'End of lp inversion. Number of iterations: %i\n',count);
%             fprintf('Final data misfit: %8.3e. Final l1-model error: %8.3e\n\n',phi_d(count),norm(m-model_out,1))
fclose(fid);
counter = counter+1;
            
 


