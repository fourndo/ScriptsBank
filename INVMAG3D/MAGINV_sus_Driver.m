% Inversion code with lp,lq norm for 3D magnetostatic problem
% Read input file and proceede with inversion
% 
% DEVELOPMENT CODE
% Under sub-functions are required to run the code
% Written by: Dominique Fournier 
% Last update: July 1th, 2014

clear all
close all

addpath ..\FUNC_LIB\;
% Project folders
work_dir = 'C:\Users\dominiquef.MIRAGEOSCIENCE\ownCloud\Research\Modelling\Synthetic\Nut_Cracker\Induced_MAG3C';
inpfile   = 'MAG3Cinv.inp'; 

dsep = '\';

[meshfile,obsfile,topofile,mstart,mref,magfile,weightfile,chi_target,alphas,beta,bounds,norm_vec,eps_p,eps_q,FLAG1,FLAG2, ROT] = MAG3Cinv_read_inp([work_dir dsep inpfile]);

% mtrue = load([work_dir '\..\Effec_sus.sus']);
% Load mesh file and convert to vectors (UBC format)
[xn,yn,zn] = read_UBC_mesh([work_dir dsep meshfile]);
dx = xn(2:end) - xn(1:end-1); nx = length(dx);
dy = yn(2:end) - yn(1:end-1); ny = length(dy);
dz = zn(1:end-1) - zn(2:end); nz = length(dz);

mcell = (length(xn)-1) * (length(yn)-1) * (length(zn)-1);


%% Load observation file (3C UBC-MAG format)
[H, BI, BD, MI, MD, dtype, obsx, obsy, obsz, d, wd] = read_MAG3D_obs([work_dir dsep obsfile]);
% plot_mag3C(obsx,obsy,d,I,D,'Observed 3C-data')
% plot_TMI(obsx,obsy,d,d,wd,'Observed vs Predicted Magnitude');

ndata = length(d);
Wd   = spdiags(1./wd,0,ndata,ndata);

%% Create model magnetization vectors
% Load magnetization model
if isempty(magfile) == 1
    
    mag_azmdip = [ones(mcell,1)*MD ones(mcell,1)*MI];
    mag_xyz = azmdip_2_xyz( mag_azmdip(:,1) , mag_azmdip(:,2) );
    
else
    
    mag_xyz = load([work_dir dsep magfile]);
    
end

% Load weights model
if isempty(weightfile) == 1
    
    w = ones(4*mcell,1);
    
else
    
    w = load([work_dir dsep weightfile]);
    
end

% Create or load reference model
if ischar(mref)==1
    
    mref = load([work_dir dsep mref]);
    
else
    
    mref = ones(mcell,1)*mref;
    
end

% Create or load reference model
if ischar(mstart)==1
    
    mstart = load([work_dir dsep mstart]);
    
else
    
    mstart = ones(mcell,1)*mstart;
    
end

% w = load([work_dir '\w.dat']);

% Create bound vector
lowBvec = ones(mcell,1) * bounds(1);
uppBvec = ones(mcell,1) * bounds(2);

%% Load topography
if isempty(topofile)==1
    
    nullcell = ones(nx*ny*nz,1);
    
else
    % Load topo
    topo = read_UBC_topo([work_dir dsep topofile]);
    [nullcell,tcell,~] = topocheck(xn,yn,zn,topo+1e-5);
    
end

save([work_dir dsep 'nullcell.dat'],'-ascii','nullcell');
%% Initialize dynamic cells
% Create selector matrix for active cells
X = spdiags(nullcell,0,mcell,mcell);
X = X(nullcell==1,:);

mactv = sum(nullcell);

mstart = X * mstart;
mref = X * mref;
mag_xyz = X * mag_xyz;
lowBvec = X* lowBvec;
uppBvec = X * uppBvec;

%% Generate s and t vectors for the different lp zones
if ischar(norm_vec)==1
    
    lpmat = load([work_dir dsep norm_vec]);
    [s,LP] = find_zones(lpmat);

    % Smooth out the regions with 8-point averager
    % Power determine the transition length
    A = get_AVG_8pt(dx,dy,dz);
    A = A*(A*A);
    A = spdiags(1./sum(A,2),0,mcell,mcell) *A;
    
    trans = A*s;
    t = X * trans;
    
    s = trans==1;
    s = X * s;
    
else
    
    LP = norm_vec;
    s= X * ones(mcell,1);
    t= X * ones(mcell,1);

end


%% Create model magnetization vectors
% Azimuth and dip of magnitization
M = [spdiags(H * mag_xyz(:,1),0,mactv,mactv);spdiags(H * mag_xyz(:,2),0,mactv,mactv);spdiags(H * mag_xyz(:,3),0,mactv,mactv)];


%% Load T matrix generated by FMAG3C
% load([work_dir '\G']);
[G,~,~] = MAGSEN_Func(work_dir,dsep,xn,yn,zn, H, BI, BD, MI, MD, dtype, obsx, obsy, obsz,nullcell, 'NULL', 'G', 3, min(dx)/4);

G = (G * M);

%% Apply data weighting
G   = Wd * G;
d = Wd * d;

%% Create gradient matrices and corresponding volume vectors
% [~, gx, gy, gz, V, Vx, Vy, Vz] = get_GRAD_op3D_SQUARE_Kron(dx,dy,dz,nullcell,'FWR');
% [~, gx_b, gy_b, gz_b, ~, ~, ~, ~] = get_GRAD_op3D_SQUARE_Kron(dx,dy,dz,nullcell,'BACK');
% [Ws, V ] = getWs3D(dx,dy,dz,X);
[A, GRAD, V] = get_GRAD_op3D_TENSIL_Kron(dx,dy,dz,nullcell,'FWR');


%% Compute depth weighting
% wr = get_wr(obsx, obsy, obsz, D, I, xn, yn, zn, nullcell, wr_flag);
% save([work_dir '\wr.dat'],'-ascii','wr');

% wr = load([work_dir '\wr.dat']);
%### TEST USING APPROXIMATE SENSITIVITY
wr = sqrt(sum(G.^2,1));
wr = sqrt(wr'/max(wr));

%%
Ws =  V * spdiags(X * ( w(1:mcell)  ).* wr ,0,mactv,mactv);
Wx =  V * spdiags(X * ( w(1+mcell:2*mcell)  ).* wr ,0,mactv,mactv);
Wy =  V * spdiags(X * ( w(1+2*mcell:3*mcell)  ).* wr ,0,mactv,mactv);
Wz =  V * spdiags(X * ( w(1+3*mcell:4*mcell)  ).* wr ,0,mactv,mactv);



%% Rotate gradient operators

Rz = @(x)   [cosd(x) -sind(x) 0;
            sind(x) cosd(x) 0;
            0 0 1];

Ry = @(x)   [cosd(x) 0 -sind(x);
            0 1 0;
            sind(x) 0 cosd(x)];

Rx = @(x)   [1 0 0;
            0 cosd(x) -sind(x);
            0 sind(x) cosd(x)];
        
rz = Rz(ROT(1));
%     rz = rz*spdiags(sum(abs(rz),2).^-1,0,3,3);

ry = Ry(ROT(2));
%     ry = ry*spdiags(sum(abs(ry),2).^-1,0,3,3);

rx = Rx(ROT(3));

rot = rx*ry*rz;
% Scale the rows


% Get index and weight for gradients Gx
[val,ind] = sort(45 - acosd(A*rot(1,:)'),'descend') ;

Gx = GRAD{ind(1)} * val(1);
denom = val(1);
count = 2;
while denom < (45 - 1e-4)
    
    Gx = Gx + GRAD{ind(count)} * val(count);
    denom = denom + val(count);
    count = count + 1;
    
end

Gx = Gx * spdiags(ones(mactv,1)/denom,0,mactv,mactv);
% indx = round(sum(abs(Gx),2)) ~= 2;
% Gx(indx,:) = 0;

% Get index and weight for gradients Gx
[val,ind] = sort(45 - acosd(A*rot(2,:)'),'descend') ;

Gy = GRAD{ind(1)} * val(1);
denom = val(1);
count = 2;
while denom < (45 - 1e-4)
    
    Gy = Gy + GRAD{ind(count)} * val(count);
    denom = denom + val(count);
    count = count + 1;
    
end

Gy = Gy * spdiags(ones(mactv,1)/denom,0,mactv,mactv);
% indx = round(sum(abs(Gy),2)) ~= 2;
% Gy(indx,:) = 0;


% Get index and weight for gradients Gx
[val,ind] = sort(45 - acosd(A*rot(3,:)'),'descend') ;

Gz = GRAD{ind(1)} * val(1);
denom = val(1);
count = 2;
while denom < (45 - 1e-4)
    
    Gz = Gz + GRAD{ind(count)} * val(count);
    denom = denom + val(count);
    count = count + 1;
    
end

Gz = Gz * spdiags(ones(mactv,1)/denom,0,mactv,mactv);



%% START INVERSION

target = chi_target * ndata;     % Target misifit

% Compute total objective function
objfunc = @(m,phim,b) sum( ( G * m - d ).^2 ) + (m)' * b * phim * (m);

% Initialize inversion
invmod      = mstart;       % Initial model       

phi_init    = sum((G * invmod - d).^2);   % Initial misfit
phi_d       = phi_init;        


% Message prompt
% head = ['lp' num2str(pvec) '_lq' num2str(qvec) '_mu' num2str(ll)];
logfile = [work_dir '\MAG3C_TMI.log'];
fid = fopen(logfile,'w');
fprintf(fid,'Starting lp inversion \n');
fprintf(fid,'Starting misfit %e\n',phi_init);
fprintf(fid,'Target misfit %e\n',target);
fprintf(fid,'Iteration:\t\tBeta\t\tphid\t\tphis\t\t ');
fprintf(fid,'phix\t\tphiy\t\tphiz\t\tphim\t\tphi\t\t ');
fprintf(fid,'#cut cells \t # CG Iter\n');


% Initiate active cell
Pac = speye(mactv);


count= 0; % Initiate iteration count 
tncg = 0; % Compute total number of CG iterations for the whole inversion
% leml = 0;
phi = [];
phi_m = [];

lp_count = 0;
dphim = 1;
switcher = 0; % Switcher defines the different modes of the inversion
% switcher 0: Run the usual l2-l2 inversion, beta decreases by 2
% switcher 1: Run the lp-lq inversion, beta decreases by 0.8
% swircher 2: End on inversion - model update < treshold


while switcher ~= 3 


    count=count+1;

    if switcher == 0     

        if isempty(eps_p)
            delta_p(count) = 0.1;
        else
            delta_p(count) = eps_p;
        end

        if isempty(eps_q)
            delta_q(count) = 0.1;
        else
            delta_q(count) = eps_q;
        end
%                     [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF(invmod,V,Ws,Vx,Wx,Vy,Wy,Vz,Wz,alpha,2,2,1);
        [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF_3D(invmod,mref,1,Ws,Wx,Wy,Wz,Gx,Gy,Gz,ones(mactv,1),alphas,[2 2 2 2 1],FLAG1,FLAG2,switcher,delta_p(count),delta_q(count));

        if isempty(beta)==1

            temp = randn(mactv,1);
%             beta = sum(G*temp.^2) / (temp'*MOF*temp) * 1e+4 ;
            beta = 1e+3;
        end

        phi(count) = norm(G*invmod - d).^2 +...
                    invmod' * beta(count) * MOF * invmod;
%         tresh = dkdt(2,delta(count));
%         tresh_s = 1;
%         tresh_xyz = 1;
    else

        lp_count = lp_count + 1;

        if lp_count == 1
%             target = target /10;
            % Fix treshold for smallness term
            [epsp,epsq] = get_eps(invmod,10,Gx,Gy,Gz);
            if isempty(eps_p)
                eps_p = epsp;
            end

            if isempty(eps_q)
                eps_q = epsq;
            end

            model_out =  X'*invmod;
            model_out(nullcell==0) = -100;
            save([work_dir dsep 'MAG3D_TMI_l2l2.sus'],'-ascii','model_out');
            write_MAG3D_TMI([work_dir dsep 'MAG3D_TMI_l2l2.pre'],H,BI,BD,MI,MD,obsx,obsy,obsz,(G*invmod).*wd,wd);

        end

        if delta_p(end) > eps_p %&& switcher == 1%(dphi_p(end) > 2 || lp_count ==1) && switch_p == 0

%             delta_p(count) = delta_p(count-1)*.5;
            delta_p(count) = eps_p;
            if delta_p(count) < eps_p

                delta_p(count) = eps_p;

            end
        else 

            delta_p(count) = delta_p(count-1);%delta_p(count-1);

        end

        if delta_q(end)> eps_q %&& switcher == 1%(dphi_q(end) > 2 || lp_count ==1) && switch_q == 0

%             delta_q(count) = delta_q(count-1)*.5;
            delta_q(count) = eps_q;
            if delta_q(count) < eps_q

                delta_q(count) = eps_q;

            end

        else

            switch_q = 1;
            delta_q(count) = delta_q(count-1);%delta_q(count-1);

        end


        if dphim(end)  < 1 && lp_count>1%traffic_s(end)*100 <= 1  && traffic_xyz(end)*100 <= 1

            fprintf('\n# # ADJUST BETA # #\n');
            switcher = 2;

        else

            fprintf('\n# # LP-LQ ITER# #\n');

        end


        [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF_3D(invmod,mref,phi_m(end),Ws,Wx,Wy,Wz,Gx,Gy,Gz,t,alphas,LP,FLAG1,FLAG2,switcher,delta_p(count),delta_q(count));

%         tresh = dkdt(LP(:,1),delta(count));


    end

    m_in = invmod;
    %dmdx = sqrt( (Wx * invmod).^2 + (Wy * invmod).^2 + (Wz * invmod).^2 );

%     group_s(count) = sum(abs(m_in) <= eps_p);
%     group_xyz(count) = sum(abs(dmdx) <= eps_q);

    %% Jacobi Pre-conditionner
    diagA = sum(G.^2,1) + beta(count)*spdiags(MOF,0)';
    PreC     = Pac * spdiags(1./diagA(:),0,mactv,mactv);

    %% Gauss-Newton steps

    fprintf('\n# # # # # # # # #\n');
    fprintf('BETA ITER: \t %i  \nbeta: \t %8.5e \n',count,beta(count));
    fprintf('eps_p: \t %8.5e \t eps_p*: \t %8.5e\n',delta_p(count),eps_p)
    fprintf('eps_q: \t %8.5e \t eps_q*: \t %8.5e\n',delta_q(count),eps_q)
    % Save previous model before GN step


    [invmod, ncg, Pac] = GN_PCG_solver( G, invmod, mref, d, phi(end), beta(count) , PreC, Pac, lowBvec, uppBvec, MOF, aVRWs, aVRWx, aVRWy, aVRWz, FLAG1 );

    tncg = tncg + ncg;

    %% Save iteration and continue


%         % Measure the update length
%         if count==1 
% 
%             rdm(count) =  1;
%             gdm(1) = norm(m_in - invmod);
% 
%         else
% 
%             gdm(2) = norm(m_in - invmod);
%             rdm(count) = abs( gdm(2) - gdm(1) ) / norm(invmod);
% 
%             gdm(1) = gdm(2);
% 
%         end

    phi_d(count) = sum(( G*invmod - d ).^2);
    phi_m(count) = (invmod)'*(MOF)*(invmod);
    phi(count) = objfunc(invmod,MOF,beta(count));

    if count ~= 1

        dphim(count) = abs(phi_m(count) - phi_m(count-1)) / phi_m(count) *100;

    end
    % Get truncated cells
    tcells = spdiags(Pac);



    fprintf(' phi_d:\t %8.5e \n',phi_d(count))
    fprintf(' phi_m:\t %8.5e \n',phi_m(count))
    fprintf(' dphi_m:\t %8.5e \n',dphim(count))


    fprintf('Number of Inactive cells: %i\n',sum(tcells));
    fprintf('Number of CGS iterations: %i\n\n',ncg);

    % Get next beta
    [switcher,beta(count+1)] = cool_beta(beta(count),phi_d(count),dphim(count),target,switcher,0.25,1);


    % Right log file
    fprintf(fid,' \t %i \t %8.5e ',count,beta(count));
    fprintf(fid,' \t %8.5e ',phi_d(count));
    fprintf(fid,' \t %8.5e ',sum( (aVRWs*invmod).^2 ) );
    fprintf(fid,' \t %8.5e ',sum( (aVRWx*invmod).^2 ));
    fprintf(fid,' \t %8.5e ',sum( (aVRWy*invmod).^2 ));
    fprintf(fid,' \t %8.5e ',sum( (aVRWz*invmod).^2 ));
    fprintf(fid,' \t %8.5e ',invmod'*MOF*invmod);
    fprintf(fid,' \t %8.5e ',phi(count));
    fprintf(fid,' \t\t %i ',sum(tcells));
    fprintf(fid,' \t\t %i\n',ncg);



    model_out =  X'*invmod;
    model_out(nullcell==0) = -100;
    save([work_dir dsep 'MAG3D_TMI_lplq.sus'],'-ascii','model_out')
%         write_MAG3D_TMI([work_dir dsep 'MAG3D_TMI_lplq.pre'],H,BI,BD,MI,MD,obsx,obsy,obsz,(G*invmod).*wd,wd);

end