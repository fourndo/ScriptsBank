function [d_out] = RemRem_Tiled(work_dir,dsep,idx,xn,yn,zn,H,I,D,Dazm, obsx, obsy,obsz, Tx, Ty, Tz,d,wd,mstart,mref,w,chi_target,alphas,beta,bounds,FLAG1,FLAG2,pads)
% Amplitude inversion code
% Dominique Fournier 
% Last update: May 31th, 2015


% Load mesh file and convert to vectors (UBC format)
% [xn,yn,zn] = read_UBC_mesh([work_dir '\' meshfile]);
dx = xn(2:end) - xn(1:end-1); nx = length(dx);
dy = yn(2:end) - yn(1:end-1); ny = length(dy);
dz = zn(1:end-1) - zn(2:end); nz = length(dz);

mcell = (length(xn)-1) * (length(yn)-1) * (length(zn)-1);


%% Load observation file (3C UBC-MAG format)
% [H, I, Dazm, D, obsx, obsy, obsz, d, wd] = read_MAG3D_obs([work_dir '\' obsfile]);
% plot_mag3C(obsx,obsy,d,I,D,'Observed 3C-data')
% plot_TMI(obsx,obsy,d,d,wd,'Observed vs Predicted Magnitude');

ndata = length(d);
% wd = ones(ndata,1);
Wd   = spdiags(1./wd,0,ndata,ndata);


load([work_dir dsep 'nullcell.dat']);

% Create bound vector
lowBvec = ones(mcell,1) * bounds(1);
uppBvec = ones(mcell,1) * bounds(2);

%% Initialize dynamic cells
% load([work_dir '\nullcell.dat']);

% Create selector matrix for active cells
X = spdiags(nullcell,0,mcell,mcell);
X = X(nullcell==1,:);

mactv = sum(nullcell);

mstart = X * mstart;
mref = X * mref;

mag_azmdip = [ones(mcell,1)*Dazm ones(mcell,1)*I];
mag_xyz = azmdip_2_xyz( mag_azmdip(:,1) , mag_azmdip(:,2) );
    
lowBvec = X* lowBvec;
uppBvec = X * uppBvec;

%% Create model magnetization vectors
% Azimuth and dip of magnitization

M = [spdiags(H * mag_xyz(:,1),0,mactv,mactv);spdiags(H * mag_xyz(:,2),0,mactv,mactv);spdiags(H * mag_xyz(:,3),0,mactv,mactv)];


%% Load T matrix generated by FMAG3C

%% Compute depth weighting
% wr = get_wr(obsx, obsy, obsz, D, I, xn, yn, zn, nullcell, wr_flag);
% save([work_dir '\wr.dat'],'-ascii','wr');
wr = load([work_dir dsep 'wr.dat']);
% wr = wr.^(4/5);
% wr = X * wr;
% Wr = spdiags(wr,0,mactv,mactv);
% IWr = spdiags(1./wr,0,mactv,mactv);
%% Create gradient matrices and corresponding volume vectors
[~, Gx, Gy, Gz, V, Vx, Vy, Vz] = get_GRAD_op3D_SQUARE(dx,dy,dz,nullcell,X);
% [Ws, V ] = getWs3D(dx,dy,dz,X);

Ws =  V * spdiags(X * ( w(1:mcell) .* wr ) ,0,mactv,mactv);
Wx =  Vx * spdiags(X * ( w(1+mcell:2*mcell) .* wr ) ,0,mactv,mactv);
Wy =  Vy * spdiags(X * ( w(1+2*mcell:3*mcell) .* wr ) ,0,mactv,mactv);
Wz =  Vz * spdiags(X * ( w(1+3*mcell:4*mcell) .* wr ) ,0,mactv,mactv);



%% Forward operator and apply depth weighting
fprintf('Loading Sensitivity...\n');
% load([work_dir '\Tx']);

TMI = [(cosd(I) * cosd(D)) (cosd(I) * sind(D)) sind(I)];
G = zeros(ndata,mactv);

for ii = 1 : ndata
    
G(ii,:) = TMI * [Tx(ii,:);Ty(ii,:);Tz(ii,:)] * M;

end

clear Tx Ty Tz
%% Apply data weighting
G = Wd * G;

d = Wd * d;

%% Inversion
target = chi_target * ndata;     % Target misifit

% Compute total objective function
objfunc = @(m,phim,b) sum( ( G * m - d ).^2 ) + (m)' * b * phim * (m);

% Initialize inversion
invmod      = mstart;       % Initial model       

phi_init    = sum((G * invmod - d).^2);   % Initial misfit
phi_d       = phi_init;        

% Initiate active cell
Pac = speye(mactv);

count= 0; % Initiate iteration count 

lp_count = 0;


count= 0; % Initiate iteration count 
tncg = 0; % Compute total number of CG iterations for the whole inversion
% leml = 0;
phi = [];
phi_m = [];
lp_count = 0;
switcher = 0; % Switcher defines the different modes of the inversion
% switcher 0: Run the usual l2-l2 inversion, beta decreases by 2
% switcher 1: Run the lp-lq inversion, beta decreases by 0.8
% swircher 2: End on inversion - model update < treshold

% dkdt = @(p,ep) (ep).^(1/(2*(2-p)));
t= ones(mactv,1);
dphim = 100;
while switcher ~= 3 

    count=count+1;
      


    if switcher == 0     
              
        [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF_3D_v2(invmod,mref,1,Ws,Wx,Wy,Wz,Gx,Gy,Gz,t,alphas,[2 2 2 2 1],FLAG1,FLAG2,switcher,1e-5,1e-5);

        if isempty(beta)==1

            temp = randn(mactv,1);
            beta = sum(G*temp.^2) / (temp'*MOF*temp) * 5e+3 ;

        end
        
        phi(count) = norm(G*invmod - d).^2 +...
                    invmod' * beta(count) * MOF * invmod;
%         tresh = dkdt(2,delta(count));
        tresh_s = 1;
        tresh_xyz = 1;
    else

        lp_count = lp_count+1;
        
        
        
        if dphim(end)  < 10
            fprintf('\n# # ADJUST BETA # #\n');
            switcher = 2;
            
        else
            
            fprintf('\n# # LP-LQ ITER# #\n');
            
        end
          
        
        [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF_3D_v2(invmod,mref,phi_m(end),Ws,Wx,Wy,Wz,Gx,Gy,Gz,t,alphas,[2 2 2 2 1],FLAG1,FLAG2,switcher,1e-5,1e-5);

%         tresh = dkdt(LP(:,1),delta(count));

        
    end
    
    m_in = invmod;

    
    %% Pre-conditionner
    diagA = sum(G.^2,1) + beta(count)*spdiags(MOF,0)';
    PreC     = Pac * spdiags(1./diagA(:),0,mactv,mactv);

    %% Gauss-Newton steps

    fprintf('\n# # # # # # # # #\n');
    fprintf('BETA ITER: \t %i  \nbeta: \t %8.5e \n',count,beta(count));
    
    % Save previous model before GN step
    
    
    [invmod, ncg, Pac] = GN_PCG_solver( G, invmod, mref, nullcell, d, phi(end), beta(count) , PreC, Pac, lowBvec, uppBvec, MOF, aVRWs, aVRWx, aVRWy, aVRWz, FLAG1 );
    tncg = tncg + ncg;
    
    %% Save iteration and continue

    % Measure traffic around the lp corner
%     if lp_count >= 1  
%         
%         temp = sum(abs(invmod) <= tresh_s);
%         traffic_s(count) = abs(group_s(count) - temp) / group_s(count);
%         
%         dmdx = sqrt( (Wx * invmod).^2 + (Wy * invmod).^2 + (Wz * invmod).^2 );
%         temp = sum(abs(dmdx) <= tresh_xyz);
%         traffic_xyz(count) = abs(group_xyz(count) - temp) / group_xyz(count);
%         
% 
%     end
    
    % Measure the update length
    if count==1 
        
        rdm(count) =  1;
        gdm(1) = norm(m_in - invmod);
        
    else
        
        gdm(2) = norm(m_in - invmod);
        rdm(count) = abs( gdm(2) - gdm(1) ) / norm(invmod);
    
        gdm(1) = gdm(2);
        
    end
    
    phi_d(count) = sum(( G*invmod - d ).^2);
    phi_m(count) = (invmod)'*(MOF)*(invmod);
    phi(count) = objfunc(invmod,MOF,beta(count));
    
    if count ~= 1
        
        dphim(count) = abs(phi(count) - phi(count-1)) / phi(count) *100;
        
    end

    
%     fprintf('---------->\n')
    fprintf(' phi_d:\t %8.5e \n',phi_d(count))
    fprintf(' phi_m:\t %8.5e \n',phi_m(count))
    fprintf(' dphi_m:\t %8.5e \n',dphim(count))
    

    % Get next beta
    [switcher,beta(count+1)] = cool_beta(beta(count),phi_d(count),dphim(count),target,switcher,0.25,10);


    m_out =  X'*invmod;
    m_out(nullcell==0) = -100;

   save([work_dir dsep 'Tile' num2str(idx) '_MAG3D.sus'],'-ascii','m_out')

end


%% Remove core and forward model padding cells
m_out = reshape(m_out,nz,nx,ny);
m_out(1:end-5,pads(1)+1:end-pads(1),pads(2)+1:end-pads(2)) = 0;


reg_d = (G*X*m_out(:));

% Compute regional removed data
d_out = ( d - reg_d ) .* wd;

write_MAG3D_TMI([work_dir dsep 'Tile' num2str(idx) '_RegRem.tmi'],H,I,Dazm,obsx,obsy,obsz,d_out,wd);

