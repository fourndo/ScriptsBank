function MAGINV_sus_Tiled(work_dir,out_dir,dsep,tileid,xn,yn,zn,H, I, Dazm, obsx, obsy, obsz, G, d, wd,mag_xyz,w,mref,mstart,bounds,chi_target,alphas,beta,LP,t,FLAG1,FLAG2)
% Function MAGSEN_Tiles(work_dir,meshfile,obsfile,topofile, wr_flag, sen_flag)
% Generate sensitivity matrix for MAG3D style inversion
%
% INPUT VARIABLES
% work_dir : Working directory where input files are and sensitivity saved
% meshfile : Mesh file
% obsfile  : Observation file in UBC format
% Inversion code with lp,lq norm for 3D magnetostatic problem
% Read input file and proceede with inversion
% 
% DEVELOPMENT CODE
% Under sub-functions are required to run the code
% Written by: Dominique Fournier 
% Last update: July 1th, 2014
dx = xn(2:end) - xn(1:end-1); nx = length(dx);
dy = yn(2:end) - yn(1:end-1); ny = length(dy);
dz = zn(1:end-1) - zn(2:end); nz = length(dz);

mcell = (length(xn)-1) * (length(yn)-1) * (length(zn)-1);

pct_cutoff = 70;

%% Create sensitivity weighting matrix
ndata = length(d);
Wd   = spdiags(1./wd,0,ndata,ndata);

% beta = [];
% chi_target = 1;

%% Create bound vector
lowBvec = ones(mcell,1) * bounds(1);
uppBvec = ones(mcell,1) * bounds(2);


%% Initialize dynamic cells
load([work_dir dsep 'nullcell.dat']);

% Create selector matrix for active cells
X = spdiags(nullcell,0,mcell,mcell);
X = X(nullcell==1,:);

mactv = sum(nullcell);

mstart = X * mstart;
mref = X * mref;
mag_xyz = X * mag_xyz;
lowBvec = X* lowBvec;
uppBvec = X * uppBvec;

t = X*t;

%% Compute depth weighting
% wr = get_wr(obsx, obsy, obsz, D, I, xn, yn, zn, nullcell, wr_flag);
% save([work_dir '\wr.dat'],'-ascii','wr');
load([work_dir dsep 'wr.dat']);

% wr = X * wr;
% Wr = spdiags(wr,0,mcell,mcell);

%% Create gradient matrices and corresponding volume vectors
[~, Gx, Gy, Gz, V, ~, ~, ~] = get_GRAD_op3D_SQUARE(dx,dy,dz,nullcell,X);
% [Ws, V ] = getWs3D(dx,dy,dz,X);

Ws =  V * spdiags(X * ( w(1:mcell) .* wr ) ,0,mactv,mactv);
Wx =  V * spdiags(X * ( w(1+mcell:2*mcell) .* wr ) ,0,mactv,mactv);
Wy =  V * spdiags(X * ( w(1+2*mcell:3*mcell) .* wr ) ,0,mactv,mactv);
Wz =  V * spdiags(X * ( w(1+3*mcell:4*mcell) .* wr ) ,0,mactv,mactv);



%% Create model magnetization vectors
% Azimuth and dip of magnitization

M = [spdiags(H * mag_xyz(:,1),0,mactv,mactv);spdiags(H * mag_xyz(:,2),0,mactv,mactv);spdiags(H * mag_xyz(:,3),0,mactv,mactv)];

%% TMI forward projector
% nstn = length(obsx);
% Ptmi = [spdiags(ones(nstn,1)* (cosd(I) * cosd(D)),0,nstn,nstn) ...
%     spdiags(ones(nstn,1)* (cosd(I) * sind(D)),0,nstn,nstn) ...
%     spdiags(ones(nstn,1)* sind(I),0,nstn,nstn)];


%% Load T matrix generated by FMAG3C
% load([work_dir '\G']);

G = (G * M);


%% Apply data weighting
G   = Wd * G;
d = Wd * d;

%% START INVERSION
    
target = chi_target * ndata;     % Target misifit

% Compute total objective function
objfunc = @(m,phim,b) sum( ( G * m - d ).^2 ) + (m)' * b * phim * (m);

% Initialize inversion
invmod      = mstart;       % Initial model       

phi_init    = sum((G * invmod - d).^2);   % Initial misfit
phi_d       = phi_init;        


% Message prompt
% head = ['lp' num2str(pvec) '_lq' num2str(qvec) '_mu' num2str(ll)];
logfile = [work_dir dsep 'MAG3C_TMI.log'];
fid = fopen(logfile,'w');
fprintf(fid,'Starting lp inversion \n');
fprintf(fid,'Starting misfit %e\n',phi_init);
fprintf(fid,'Target misfit %e\n',target);
fprintf(fid,'Iteration:\t\tBeta\t\tphid\t\tphis\t\t ');
fprintf(fid,'phix\t\tphiy\t\tphiz\t\tphim\t\tphi\t\t ');
fprintf(fid,'#cut cells \t # CG Iter\n');


% Initiate active cell
Pac = speye(mactv);


count= 0; % Initiate iteration count 
tncg = 0; % Compute total number of CG iterations for the whole inversion
% leml = 0;
phi = [];
phi_m = [];
lp_count = 0;
dphim = 1;
switcher = 0; % Switcher defines the different modes of the inversion
% switcher 0: Run the usual l2-l2 inversion, beta decreases by 2
% switcher 1: Run the lp-lq inversion, beta decreases by 0.8
% swircher 2: End on inversion - model update < treshold

% dkdt = @(p,ep) (ep).^(1/(2*(2-p)));

while switcher ~= 3 


    count=count+1;
    
    if switcher == 0     
        
        eps_p = 0.1;
        eps_q = 0.1;
        
        delta_p(count) = eps_p;
        delta_q(count) = eps_q;
        
%                     [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF(invmod,V,Ws,Vx,Wx,Vy,Wy,Vz,Wz,alpha,2,2,1);
        [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF_3D_v2(invmod,mref,1,Ws,Wx,Wy,Wz,Gx,Gy,Gz,t,alphas,[2 2 2 2 1],FLAG1,FLAG2,switcher,delta_p(count),delta_q(count));

        if isempty(beta)==1

            temp = randn(mactv,1);
            beta = sum(G*temp.^2) / (temp'*MOF*temp) * 1e+5 ;

        end
        
        phi(count) = norm(G*invmod - d).^2 +...
                    invmod' * beta(count) * MOF * invmod;
%         tresh = dkdt(2,delta(count));
        tresh_s = 0.001;
        tresh_xyz = 1;
    else

        lp_count = lp_count+1;
        
        if lp_count == 1
%             target = target /10;
            % Fix treshold for smallness term
            [eps_p,eps_q] = get_eps(invmod,10,Gx,Gy,Gz);
            %             eps_q=1e-5;
            %             eps_p=1e-5;
            eps_p = eps_p/5;
            eps_q = eps_q/5;
            
            model_out =  X'*invmod;
            model_out(nullcell==0) = -100;
            save([work_dir dsep 'Tile' num2str(tileid) '_MAG3D_l2l2.sus'],'-ascii','model_out')
            
        end
            
        if delta_p(end)> eps_p %&& switcher == 1%(dphi_p(end) > 2 || lp_count ==1) && switch_p == 0
                            
            delta_p(count) = delta_p(count-1)*.5;

            if delta_p(count) < eps_p

                delta_p(count) = eps_p;

            end
        else 

            delta_p(count) = delta_p(count-1);%delta_p(count-1);

        end

        if delta_q(end)> eps_q %&& switcher == 1%(dphi_q(end) > 2 || lp_count ==1) && switch_q == 0

            delta_q(count) = delta_q(count-1)*.5;

            if delta_q(count) < eps_q

                delta_q(count) = eps_q;

            end

        else

            switch_q = 1;
            delta_q(count) = delta_q(count-1);%delta_q(count-1);

        end

                
        if dphim(end)  < 5 && delta_p(count) == eps_p && delta_q(count) == eps_q%traffic_s(end)*100 <= 1  && traffic_xyz(end)*100 <= 1
            
            fprintf('\n# # ADJUST BETA # #\n');
            switcher = 2;
            
        else
            
            fprintf('\n# # LP-LQ ITER# #\n');
            
        end
          
        
        [MOF,aVRWs,aVRWx,aVRWy,aVRWz] = get_lp_MOF_3D_v2(invmod,mref,phi_m(end),Ws,Wx,Wy,Wz,Gx,Gy,Gz,t,alphas,LP,FLAG1,FLAG2,switcher,delta_p(count),delta_q(count));

        
    end
    
    m_in = invmod;
    
    
    %% Pre-conditionner
    diagA = sum(G.^2,1) + beta(count)*spdiags(MOF,0)';
    PreC     = Pac * spdiags(1./diagA(:),0,mactv,mactv);

    %% Gauss-Newton steps

    fprintf('\n# # # # # # # # #\n');
    fprintf('BETA ITER: \t %i  \nbeta: \t %8.5e \n',count,beta(count));
    fprintf('eps_p: \t %8.5e \t eps_p*: \t %8.5e\n',delta_p(count),eps_p)
    fprintf('eps_q: \t %8.5e \t eps_q*: \t %8.5e\n',delta_q(count),eps_q)
    % Save previous model before GN step
    
    
     [invmod, ncg, Pac] = GN_PCG_solver( G, invmod, mref, nullcell, d, phi(end), beta(count) , PreC, Pac, lowBvec, uppBvec, MOF, aVRWs, aVRWx, aVRWy, aVRWz, FLAG1 );
    tncg = tncg + ncg;
    
    %% Save iteration and continue
   
    % Measure the update length
    if count==1 
        
        rdm(count) =  1;
        gdm(1) = norm(m_in - invmod);
        
    else
        
        gdm(2) = norm(m_in - invmod);
        rdm(count) = abs( gdm(2) - gdm(1) ) / norm(invmod);
    
        gdm(1) = gdm(2);
        
    end
    
    phi_d(count) = sum(( G*invmod - d ).^2);
    phi_m(count) = (invmod)'*(MOF)*(invmod);
    phi(count) = objfunc(invmod,MOF,beta(count));
    
    if count ~= 1
        
        dphim(count) = abs(phi_m(count) - phi_m(count-1)) / phi_m(count) *100;
        
    end
    
    % Get truncated cells
    tcells = spdiags(Pac);
    
    
    fprintf(' phi_d:\t %8.5e \n',phi_d(count))
    fprintf(' phi_m:\t %8.5e \n',phi_m(count))
    fprintf(' dphi_m:\t %8.5e \n',dphim(count))

    
    fprintf('Number of Inactive cells: %i\n',sum(tcells));
    fprintf('Number of CGS iterations: %i\n\n',ncg);

    % Get next beta
    [switcher,beta(count+1)] = cool_beta(beta(count),phi_d(count),rdm(count),target,switcher,0.25,1e-2);


    % Right log file
    fprintf(fid,' \t %i \t %8.5e ',count,beta(count));
    fprintf(fid,' \t %8.5e ',phi_d(count));
    fprintf(fid,' \t %8.5e ',sum( (aVRWs*invmod).^2 ) );
    fprintf(fid,' \t %8.5e ',sum( (aVRWx*invmod).^2 ));
    fprintf(fid,' \t %8.5e ',sum( (aVRWy*invmod).^2 ));
    fprintf(fid,' \t %8.5e ',sum( (aVRWz*invmod).^2 ));
    fprintf(fid,' \t %8.5e ',invmod'*MOF*invmod);
    fprintf(fid,' \t %8.5e ',phi(count));
    fprintf(fid,' \t\t %i ',sum(tcells));
    fprintf(fid,' \t\t %i\n',ncg);



    model_out =  X'*invmod;
    model_out(nullcell==0) = -100;
    save([work_dir dsep 'Tile' num2str(tileid) '_MAG3D_lplq.sus'],'-ascii','model_out')
    write_MAG3D_TMI([work_dir dsep 'Tile' num2str(tileid) '_MAG3D_lplq.pre'],H,I,Dazm,obsx,obsy,obsz,(G*invmod).*wd,wd);

    Plot3D_model_frame(xn,yn,zn,model_out);
    
    axes('Position',[0.75 .5 .225 .3]);

   [h,line1,line2] = plotyy(1:count,phi_d,1:count,phi_m);
                set(line1,'LineWidth',1.5);
            set(line2,'LineWidth',1.5);
            ylabel('\phi_d');
    xlim(h(1),[0 25]);
    xlim(h(2),[0 25]);
    
    ax1 = axes('Position',[0.75 .1 .225 .3]);
    hist(invmod(invmod>1e-6),200)
    axis(ax1,[1e-6 1e-2 0 1000]);hold on
    plot([delta_p(count) delta_p(count)],[0 1000],'r')
    plot([eps_p eps_p],[0 1000],'b')
    ylabel('Hist(m)')
    xlabel('m')
    
    frame = getframe(figure(1));
    im = frame2im(frame);
    [imind,cm] = rgb2ind(im,256);
    if count == 1;
      imwrite(imind,cm,[work_dir '\field.gif'],'gif', 'Loopcount',inf,'DelayTime',0.25);
    else
      imwrite(imind,cm,[work_dir '\field.gif'],'gif','WriteMode','append','DelayTime',0.25);
    end

    close(figure(1))
end

% plot_TMI(obsx,obsy,d.*wd,(G*invmod).*wd,wd,'Obs vs Pred')
%%           
% leml = norm(invmod - mtrue,1);
fprintf(fid,'End of lp inversion. Number of iterations: %i\n',count);
fprintf(fid,'Final Number of CG iterations: %i\n',tncg);
fprintf('Final Number of CG iterations: %i\n',tncg);
%             fprintf('Final data misfit: %8.3e. Final l1-model error: %8.3e\n\n',phi_d(count),norm(m-model_out,1))
fclose(fid);

clear G

save([out_dir dsep 'Tile' num2str(tileid) '.sus'],'-ascii','model_out') 

