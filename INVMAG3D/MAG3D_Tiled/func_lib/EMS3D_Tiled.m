function [d_amp,M] = EMS3D_Tiled(work_dir,dsep,idx,xn,yn,zn,H, I, Dazm, D, obsx, obsy, obsz, data, wd,nullcell,mstart,mref,chi_target,alphas,beta,nlayer,FLAG1)
% ORTHOGONALLY MAGNETIZED EQUIVALENT SOURCE 
% Written by: Dominique Fournier 
% Last update: July 30th, 2014 
% 
% The code generates an equivalent source layer along topography. The layer
% can be use to forward model components and predict magnetization
% direction


uppB = 10;
lowB = -10;


%% 3D nodal location
[Zn,Xn,Yn] = ndgrid(zn,xn,yn);

dx = xn(2:end) - xn(1:end-1); nx = length(dx);
dy = yn(2:end) - yn(1:end-1); ny = length(dy);
dz = zn(1:end-1) - zn(2:end); nz = length(dz);

%% Load observation file (3C UBC-MAG format)
ndata = length(data);
Wd   = spdiags(1./wd,0,ndata,ndata);

nstn = length(obsx);

%% Extract active cells
% [nullcell,tcellID,ztopo_n] = topocheck(Xn,Yn,Zn,topo);
% save([work_dir '\nullcell.dat'],'-ascii','nullcell');

% Get index of surface active cells
OMESid3D = MAG3C_get_OMES_id( reshape(nullcell,nz,nx,ny) , nlayer );
% OMESid = MAG3C_get_OMES_id_v2( obsx, obsy, xn, yn, zn, nullcell, nlayer);
[~,Ii,Jj] = ind2sub([nz nx ny],OMESid3D);

mstart = kron(ones(3,1),mstart(OMESid3D));
mref = kron(ones(3,1),mref(OMESid3D));

% Remove padding outside zone
% temp = OMESid3D~=0;
% 
% OMESid3D = OMESid3D(temp);
% Ii = Ii(temp);
% Jj = Jj(temp);

OMESid2D = sub2ind([nx ny],Ii,Jj);

mcell = 3*length(OMESid2D);

% Tindex = zeros(1,nx*ny); Tindex(OMESid2D) = 1;
% Tindex = kron(Tindex,ones(1,3));


% Get nodal discretization for octree levels
% acelln = MAG3C_RTC_OctNodes(Xn,Yn,Zn,OMESid3D,ztopo_n,0);
znzn = kron(kron(ones(ny,1),ones(nx,1)),[zn(1:end-1)' zn(2:end)']);
xnxn = kron(kron(ones(ny,1),[xn(1:end-1)' xn(2:end)']),ones(nz,1));
ynyn = kron(kron([yn(1:end-1)' yn(2:end)'],ones(nx,1)),ones(nz,1));

acelln = [znzn(:,1) xnxn(:,1) ynyn(:,1) znzn(:,2) xnxn(:,2) ynyn(:,2)];
acelln = acelln(OMESid3D,:);

acelln(:,4) = acelln(:,4) - 500;
dz = dz + 500;

% acelln = reshape( acelln , , 6 );




%% TMI forward projector
Ptmi = [spdiags(ones(nstn,1)* (cosd(I) * cosd(D)),0,nstn,nstn) ...
    spdiags(ones(nstn,1)* (cosd(I) * sind(D)),0,nstn,nstn) ...
    spdiags(ones(nstn,1)* sind(I),0,nstn,nstn)];

%% Generate sensitivities matrix generated by FMAG3C
% Pre-allocate to store fields
Tx = zeros(ndata,mcell);
Ty = zeros(ndata,mcell);
Tz = zeros(ndata,mcell);

progress = -1;
tic  
for ii = 1:ndata

    
    % compute kernel for active cells
    [tx,ty,tz] = MAG3C_T(obsx(ii),obsy(ii),obsz(ii),acelln);

    Tx(ii,:) = tx*H;
    Ty(ii,:) = ty*H;
    Tz(ii,:) = tz*H;
    
    d_iter = floor(ii/ndata*20);
    if  d_iter > progress

        fprintf('Computed %i pct of data in %8.5f sec\n',d_iter*5,toc)
        progress = d_iter;

    end
            
end

G = Ptmi*[Tx;Ty;Tz];

% nactv = size(G,2)/3;

%% Create gradient matrices and corresponding volume vectors
nullcell = zeros(1,nx*ny);
nullcell(OMESid2D) = 1;
nullcell = (kron(nullcell,ones(1,nlayer)));

X = speye(nx*ny*nlayer);
X = X(nullcell==1,:);

[Ws, Wx, Wy, Wz, V, Vx, Vy, Vz] = get_GRAD_op3D_SQUARE(dx,dy,dz(1:nlayer),nullcell,X);

% [Ws, V ] = getWs3D(dx,dy,dz);
Ws = kron(speye(3), Ws);
Wx = kron(speye(3), Wx);
Wy = kron(speye(3), Wy);
Wz = kron(speye(3), sparse(size(Wz,1),size(Wz,1)));
% Vx = kron(speye(3), Vx);
% Vy = kron(speye(3), Vy);
% Vz = kron(speye(3), Vz);
V = kron( speye(3), V );


%% Apply data weighting on sensitivity
G   = Wd * G;
d = Wd * data;

%% Inversion   
target = chi_target * ndata;     % Target misifit

% Compute total objective function
comp_phi = @(m,phim,b) sum( ( G * m - d ).^2 ) + (m)' * b * phim * (m);

lowBvec = ones(mcell,1) * lowB;
uppBvec = ones(mcell,1) * uppB;             
ncg = 0;
                
% Initialize inversion
invmod      = mstart;       % Initial model       

phi_init    = sum((G * invmod - d).^2);   % Initial misfit
phi_d       = phi_init;
% phi_m       = [];         

count=1;
% countbar = 0;

% Message prompt
logfile = [work_dir dsep 'Log_EMS.log'];
fid = fopen(logfile,'w');
fprintf(fid,'Starting OMES inversion\n');
fprintf(fid,'Starting misfit %e\n',phi_init);
fprintf(fid,'Target misfit %e\n',target);
fprintf(fid,'Iteration:\t\tBeta\t\tphid\t\tphis\t\t ');
fprintf(fid,'phix\t\tphiy\t\tphiz\t\tphim\t\tphi\t\t ');
fprintf(fid,'#cut cells \t # CG Iter\n');


% Initiate active cell
lowb = zeros(mcell,1); % Logical for lower boundded cells
uppb = zeros(mcell,1); % Logical for upper boundded cells
Pac = spdiags((lowb==0).*(uppb==0),0,mcell,mcell);

WxtWx = ( V * Wx )' * ( V * Wx ) ;
WytWy = ( V * Wy )' * ( V * Wy ) ;
WztWz = ( V * Wz )' * ( V * Wz ) ;

WstWs = ( V * Ws )' * ( V * Ws ) ;

if nlayer ==1
    
    aVRWs = alphas(1) * ( V * Ws );
    aVRWx = alphas(2) * ( V * Wx );
    aVRWy = alphas(3) * ( V * Wy );
    aVRWz = sparse ( mcell , mcell );
    
else
    
    aVRWs = alphas(1) * ( V * Ws );
    aVRWx = alphas(2) * ( V * Wx );
    aVRWy = alphas(3) * ( V * Wy );
    aVRWz = alphas(4) * ( V * Wz );
    
end

if nlayer ==1
    
    MOF = alphas(1)*WstWs + alphas(2)*WxtWx + alphas(3)*WytWy;
    
else
    
    MOF = alphas(1)*WstWs + alphas(2)*WxtWx + alphas(3)*WytWy + alphas(4)*WztWz;
    
end

while phi_d(end) > target 


    %First iteration uses the usual smallness and smoothness
    %regularization. Choose a beta on the ratio of the traces 
    % of the elements of objective function
    if count==1                 

        if isempty(beta)==1
            
            m_temp = randn(mcell,1);
%             beta = full( sum(sum(G.^2,1)) / sum(diag(MOF,0)) * 1e+1 );

            beta = sum((G*m_temp).^2) / (m_temp'*MOF*m_temp) * 1e+3;
        end
%                     beta = 1e+5;

        lambda = beta ;
        phi = norm(G*invmod - d).^2 +...
            invmod' * lambda * MOF * invmod;

    else

        lambda = beta(count);

    end


    %% Pre-conditionner
    diagA = sum(G.^2,1) + lambda*spdiags(MOF,0)';
    PreC     = Pac * spdiags(1./diagA(:),0,mcell,mcell);

%     m_in = invmod;
    
    [invmod, iter, Pac] = GN_PCG_solver( G, invmod, mref, nullcell, d, phi(end), beta(count) , PreC, Pac, lowBvec, uppBvec, MOF, aVRWs, aVRWx, aVRWy, aVRWz, FLAG1 );
               
    ncg = ncg+iter; % Record the number of CG iterations

    
    %% Save iteration and continue

    phi(count) = comp_phi(invmod,MOF,lambda);

    phi_d(count) = sum(( G*invmod - d ).^2);

    % Cool beta
    if phi_d(count) < target*2 && count~=1

      beta(count+1) = 0.5 * beta(count);

    else

      beta(count+1) = 0.5 * beta(count);

    end

    fprintf(fid,' \t %i \t %8.5e ',count,beta(count));
    fprintf('Iteration: \t %i  \nBeta: \t %8.5e \n',count,beta(count));
    fprintf(fid,' \t %8.5e ',phi_d(count));
    fprintf('phid:\t %8.5e\n',phi_d(count))
    fprintf(fid,' \t %8.5e ',invmod'*alphas(1)*WstWs*invmod);
    fprintf(fid,' \t %8.5e ',invmod'*alphas(2)*WxtWx*invmod);
    fprintf(fid,' \t %8.5e ',invmod'*alphas(3)*WytWy*invmod);
    fprintf(fid,' \t %8.5e ',invmod'*alphas(4)*WztWz*invmod);
    fprintf(fid,' \t %8.5e ',invmod'*MOF*invmod);
    fprintf(fid,' \t %8.5e ',phi(count));
    fprintf(fid,' \t\t %i ',sum(lowb));
    fprintf('Number of Inactive cells: %i\n',sum(lowb));
    fprintf(fid,' \t\t %i\n',ncg);
    fprintf('Number of CGS iterations: %i\n',ncg);
   % Output interation result

%                 save([work_dir '\OMES_' 'p' num2str(pvec(pp)) 'q' num2str(qvec(qq)) 'l' num2str(lvec(ll)) '_iter_' num2str(count) '.sus'],'-ascii','model_out')
%                 write_MAG3D_TMI([work_dir '\TMI_iter_' num2str(count) '.pre'],H,I,Dazm,obsx,obsy,obsz,(G*invmod).*wd,wd)

    count=count+1; 
    
end
%%
count=count-1;  

mcell = length(OMESid2D);

mx = invmod(1:mcell);
my = invmod(1+mcell:2*mcell);
mz = invmod(1+2*mcell:3*mcell);

esus = sqrt( mx.^2 + my.^2 + mz.^2 );

% paint equivalent source layer on entire 3D mesh
esus_3D = ones(nx*ny*nz,1)*-100;%repmat(reshape(esus,nx,ny),1,1,nz);
esus_3D(OMESid3D) = esus; %esus_3D = esus_3D(:);
% esus_3D(nullcell==0) = -100;

save([work_dir dsep 'Tile' num2str(idx) '_EMS.sus'],'-ascii','esus_3D');

d_pre = G * invmod;
% plot_TMI(obsx,obsy,data,d_pre./wd,ones(ndata,1),'Observed vs Predicted Magnitude');

bx = Tx*invmod;%data_3C(1:ndata); 
by = Ty*invmod;%data_3C(ndata+1:2*ndata); 
bz = Tz*invmod;%data_3C(2*ndata+1:3*ndata); 

clear Tx Ty Tz

d_amp = sqrt(bx.^2 + by.^2 + bz.^2);

write_MAG3D_TMI([work_dir dsep 'Tile' num2str(idx) '_EMS.tmi'],H,I,Dazm,obsx,obsy,obsz,Ptmi * [bx;by;bz],wd);

write_MAG3D_TMI([work_dir dsep 'Tile' num2str(idx) '_EMS.amp'],H,I,Dazm,obsx,obsy,obsz,d_amp,wd);

write_MAG3D_3C([work_dir dsep 'Tile' num2str(idx) '_EMS_3C.tmi'],H,I,Dazm,obsx,obsy,obsz,bx,by,bz,ones(ndata,1),ones(ndata,1),ones(ndata,1));

% plot_mag3C(obsx,obsy,[bx;by;bz],I,D,'Observed 3C-Data data')

fprintf(fid,'End of OMES inversion. Number of iterations: %i\n',count);
%             fprintf('Final data misfit: %8.3e. Final l1-model error: %8.3e\n\n',phi_d(count),norm(m-model_out,1))
fclose(fid);

% Normalize magnetization vector and save to file
scale = spdiags(1./esus,0,nx*ny,nx*ny);

Mx = repmat(reshape(scale * mx,nx,ny),[1 1 nz]);
Mx = permute(Mx,[3 1 2]);

My = repmat(reshape(scale * my,nx,ny),[1 1 nz]);
My = permute(My,[3 1 2]);

Mz = repmat(reshape(scale * mz,nx,ny),[1 1 nz]);
Mz = permute(Mz,[3 1 2]);

M = [Mx(:) My(:) Mz(:)];
% M(nullcell==0,:) = 0;

save([work_dir dsep 'Tile' num2str(idx) '_EMS.fld'],'-ascii','M');
% d_amp = load([work_dir '\d_amp.dat']);


